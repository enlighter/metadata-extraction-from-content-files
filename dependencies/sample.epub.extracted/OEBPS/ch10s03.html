<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Defining custom events</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Defining custom events"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec78"/>Defining custom events</h1></div></div></div><p>The events that get triggered naturally by the DOM implementations of browsers are crucial to any interactive web <a id="id834" class="indexterm"/>application. However, we aren't limited to this set of events in our jQuery code. We can freely add our own custom events to the repertoire. We saw this briefly in <a class="link" href="ch08.html" title="Chapter&#xA0;8.&#xA0;Developing Plugins">Chapter 8</a>, <span class="emphasis"><em>Developing Plugins</em></span>, when we saw how jQuery UI widgets trigger events, but we will investigate here how we can create and use custom events, even when not writing a plugin.</p><p>Custom events must be triggered <a id="id835" class="indexterm"/>manually by our code. In a sense, they are like regular functions that we define, in that we can cause a block of code to be executed when we invoke it from another place in the script. The <code class="literal">.on()</code> <a id="id836" class="indexterm"/>call for a custom event behaves like a function definition, while the <code class="literal">.trigger()</code> <a id="id837" class="indexterm"/>call acts like a function invocation.</p><p>However, event handlers are decoupled from the code that triggers them. This means that we can trigger events at any time, without knowing in advance what will happen when we do. A regular function call causes a single piece of code to be executed. A custom event, however, could have no handlers, one handler, or many handlers bound to it. In any case, all of the bound handlers will be executed when the event is triggered.</p><p>To illustrate this, we can revise our Ajax loading feature to use a custom event. We will trigger a <code class="literal">nextPage</code> event <a id="id838" class="indexterm"/>whenever the user requests more photos, and bind handlers that watch for this event and perform the work previously done by the <code class="literal">.click()</code> handler:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#more-photos').click(function(event) {
    event.preventDefault();
<span class="strong"><strong>    $(this).trigger('nextPage');</strong></span>
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 10.9</em></span>
</p><p>The <code class="literal">.click()</code> handler <a id="id839" class="indexterm"/>now does very little work itself. It triggers the custom event and also prevents the default link behavior by calling <code class="literal">.preventDefault()</code>. The heavy <a id="id840" class="indexterm"/>lifting is <a id="id841" class="indexterm"/>transferred to the new event handlers for the <code class="literal">nextPage</code> event, as follows:</p><div class="informalexample"><pre class="programlisting">(function($) {
<span class="strong"><strong>  $(document).on('nextPage', function() {</strong></span>
    var url = $('#more-photos').attr('href');
    if (url) {
      $.get(url, function(data) {
        $('#gallery').append(data);
      });
    }
<span class="strong"><strong>  });</strong></span>

  var pageNum = 1;
<span class="strong"><strong>  $(document).on('nextPage', function() {</strong></span>
    pageNum++;
    if (pageNum &lt; 20) {
      $('#more-photos').attr('href', 'pages/' + pageNum + '.html');
    }
    else {
      $('#more-photos').remove();
    }
  });
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 10.10</em></span>
</p><p>Our code really hasn't changed much since its first expression in <span class="emphasis"><em>Listing 10.2</em></span>. The largest difference is that we've split what was <a id="id842" class="indexterm"/>once a single function into two. This is simply to illustrate that a single event trigger can cause multiple bound handlers to fire. Clicking on the <span class="strong"><strong>More Photos</strong></span> link results in the next group of pictures being appended and the link's <code class="literal">href</code> attribute being updated, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3145_10_03.jpg" alt="Defining custom events"/></div><p>With the code change in <span class="emphasis"><em>Listing 10.10</em></span> we are also illustrating another application of event bubbling. The <code class="literal">nextPage</code> <a id="id843" class="indexterm"/>handlers could be bound to the link that triggers the event, but we would need to wait to do this until the DOM was ready. Instead, we are binding the handlers to the document itself, which <a id="id844" class="indexterm"/>
<a id="id845" class="indexterm"/>is available immediately, so we can do the binding outside of <code class="literal">$(document).ready()</code>. This is, in fact, the same principle we took advantage of in <span class="emphasis"><em>Listing 10.8</em></span> when we moved the <code class="literal">.on()</code> method outside of <code class="literal">$(document).ready()</code>. The event bubbles up and, so long as another handler doesn't stop the event propagation, our handlers will be fired.</p><div class="section" title="Infinite scrolling"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec121"/>Infinite scrolling</h2></div></div></div><p>Just as multiple event handlers <a id="id846" class="indexterm"/>can react to the same triggered event, the same event can be triggered in multiple ways. We can demonstrate this by adding an infinite scrolling feature to our page. This popular technique lets the user's scroll bar manage the loading of content, fetching additional content whenever the user reaches the end of what has been loaded thus far.</p><p>We'll begin with a simple implementation, then improve it in successive examples. The basic idea is to observe the <code class="literal">scroll</code> event, measure the current scroll bar position when scrolling occurs, and load new content if needed. The following code will trigger the <code class="literal">nextPage</code> event we defined in <span class="emphasis"><em>Listing 10.10</em></span>:</p><div class="informalexample"><pre class="programlisting">(function($) {
  function checkScrollPosition() {
    var distance = $(window).scrollTop() + $(window).height();
    if ($('#container').height() &lt;= distance) {
      $(document).trigger('nextPage');
    }
  }

  $(document).ready(function() {
    $(window).scroll(checkScrollPosition).trigger('scroll');
  });
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 10.11</em></span>
</p><p>The <code class="literal">checkScrollPosition()</code> <a id="id847" class="indexterm"/>function we've introduced here is set as a handler for the window's <code class="literal">scroll</code> event. This function computes the distance from the top of the document to the bottom of the window <a id="id848" class="indexterm"/>and then compares this distance to the total height of the main container in the document. As soon as these reach equality, we need to fill the page with additional photos, so we trigger the <code class="literal">nextPage</code> event.</p><p>As soon as we bind the <code class="literal">scroll</code> handler, we immediately trigger it with a call to <code class="literal">.trigger('scroll')</code>. This kick-starts the process, so that if the page is not initially filled with photos, an Ajax request is made right away to append more photos:</p><div class="mediaobject"><img src="graphics/3145_10_04.jpg" alt="Infinite scrolling"/></div></div><div class="section" title="Custom event parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec122"/>Custom event parameters</h2></div></div></div><p>When we define functions, we can set <a id="id849" class="indexterm"/>up any number of parameters to be filled with argument values when we actually call the function. Similarly, when triggering a custom event, we may want to pass along additional information to any registered event handlers. We can accomplish this by using custom event parameters.</p><p>The first parameter defined for any event handler, as we've seen, is the DOM event object as enhanced and extended by jQuery. Any additional parameters we define are available for our discretionary use.</p><p>To see this in action, we'll add a new <a id="id850" class="indexterm"/>option to the <code class="literal">nextPage</code> event from <span class="emphasis"><em>Listing 10.10</em></span>, allowing us to scroll the page down to display the newly-added content:</p><div class="informalexample"><pre class="programlisting">(function($) {
<span class="strong"><strong>  $(document).on('nextPage', function(event, scrollToVisible) {</strong></span>
    var url = $('#more-photos').attr('href');
    if (url) {
      $.get(url, function(data) {
        var $data = $(data).appendTo('#gallery');
<span class="strong"><strong>        if (scrollToVisible) {</strong></span>
<span class="strong"><strong>          var newTop = $data.offset().top;</strong></span>
<span class="strong"><strong>          $(window).scrollTop(newTop);</strong></span>
<span class="strong"><strong>        }</strong></span>
        checkScrollPosition();
      });
    }
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 10.12</em></span>
</p><p>We have now added a <code class="literal">scrollToVisible</code> <a id="id851" class="indexterm"/>
<a id="id852" class="indexterm"/>parameter to the event callback. The value of this parameter determines whether we perform the new functionality, which entails measuring the position of the new content and scrolling to it. Measurement is easy using the <code class="literal">.offset()</code> method, which <a id="id853" class="indexterm"/>
<a id="id854" class="indexterm"/>returns the top and left coordinates of the new content. To move down the page, we call the <code class="literal">.scrollTop()</code> <a id="id855" class="indexterm"/>
<a id="id856" class="indexterm"/>method.</p><p>Now we need to pass an argument into the new parameter. All that is required is providing an extra value when invoking the event using <code class="literal">.trigger()</code>. When <code class="literal">newPage</code> is triggered via scrolling, we don't want the new behavior to occur, as the user is already manipulating the scroll position directly. When the <span class="strong"><strong>More Photos</strong></span> link is clicked, on the other hand, we want the newly-added photos to be displayed on screen, so we will pass a value of <code class="literal">true</code> to the handler:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#more-photos').click(function() {
<span class="strong"><strong>    $(this).trigger('nextPage', [true]);</strong></span>
    return false;
  });

  $(window).scroll(checkScrollPosition).trigger('scroll');
});</pre></div><p>
<span class="emphasis"><em>Listing 10.13</em></span>
</p><p>In the call to <code class="literal">.trigger()</code>, we are now providing an array of values to pass to event handlers. In this case, the value of <code class="literal">true</code> will be given to the <code class="literal">scrollToVisible</code> parameter of the event handler in <span class="emphasis"><em>Listing 10.12</em></span>.</p><p>Note that custom event parameters are optional on both sides of the transaction. We have two calls to <code class="literal">.trigger('nextPage')</code> in our code, only one of which provides argument values; when the other is called, this does <a id="id857" class="indexterm"/>not result in an error, but rather each parameter in the handler has the value <code class="literal">undefined</code>. Similarly, the lack of a <code class="literal">scrollToVisible</code> <a id="id858" class="indexterm"/>
<a id="id859" class="indexterm"/>parameter in one of our <code class="literal">.on('nextPage')</code> calls is not an error; if a parameter does not exist when an argument is passed, that argument is simply ignored.</p></div></div></body></html>
