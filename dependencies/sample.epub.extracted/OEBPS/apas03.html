<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Creating closures in jQuery</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Creating closures in jQuery"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec109"/>Creating closures in jQuery</h1></div></div></div><p>The methods we have seen <a id="id1117" class="indexterm"/>throughout the jQuery library often take at least one function as a parameter. For convenience, we often use anonymous functions so that we can <a id="id1118" class="indexterm"/>define the function behavior right when it is needed. This means that functions are rarely in the top-level namespace; they are usually inner functions, which means they can quite easily create closures.</p><div class="section" title="Passing arguments to $(document).ready()"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec154"/>Passing arguments to $(document).ready()</h2></div></div></div><p>Nearly all the code we <a id="id1119" class="indexterm"/>write using jQuery ends up getting placed inside a function passed as an argument to <code class="literal">$(document).ready()</code>. We <a id="id1120" class="indexterm"/>do this to guarantee that the DOM has loaded before the code is run, which is usually a requirement for interesting jQuery code. When a function is created and passed to <code class="literal">.ready()</code>, a reference to the function is stored as part of the global jQuery object. This reference is then called at a later time when the DOM is ready.</p><p>We usually place the <code class="literal">$(document).ready()</code> construct at the top level of the code structure, so this function is not really part of a closure. However, since our code is usually written inside this function, everything else is an inner function:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var readyVar = 0;
  function innerFn() {
    readyVar++;
    console.log('readyVar = ' + readyVar);
  }
  innerFn();
  innerFn();
});</pre></div><p>
<span class="emphasis"><em>Listing A.10</em></span>
</p><p>This looks like many of our earlier examples, except that in this case the outer function is the callback passed to <code class="literal">$(document).ready()</code>. Since <code class="literal">innerFn()</code> is defined inside of it and refers to <code class="literal">readyVar</code> which is in the scope of the <code class="literal">callback</code> function, <code class="literal">innerFn()</code> and its environment <a id="id1121" class="indexterm"/>create a closure. We can see this by noting that the value of <code class="literal">readyVar</code> persists between calls to the function:</p><div class="informalexample"><pre class="programlisting">readyVar = 1
readyVar = 2</pre></div><p>The fact that most <a id="id1122" class="indexterm"/>jQuery code is inside a function body is useful, because this can protect against some namespace collisions. For example, it is this feature that allows us to use <code class="literal">jQuery.noConflict()</code> to free up the <code class="literal">$</code> shortcut for other libraries while still being able to define the shortcut locally for use within our <code class="literal">.ready()</code> handler.</p></div><div class="section" title="Assigning event handlers"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec155"/>Assigning event handlers</h2></div></div></div><p>The <code class="literal">$(document).ready()</code> construct <a id="id1123" class="indexterm"/>usually wraps the rest of our code, <a id="id1124" class="indexterm"/>including the assignment of event handlers. Since handlers are functions, they become inner functions. Since those inner functions are stored and called later, they can create closures. </p><p>A simple <code class="literal">click</code> handler can illustrate this:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var counter = 0;
  $('#button-1').click(function(event) {
    event.preventDefault();
    counter++;
    console.log('counter = ' + counter);
  });
});</pre></div><p>
<span class="emphasis"><em>Listing A.11</em></span>
</p><p>Because the variable <code class="literal">counter</code> is <a id="id1125" class="indexterm"/>declared inside of the <code class="literal">.ready()</code> handler, it is only available to the jQuery code inside this block and not to outside code. It can be referenced by the <a id="id1126" class="indexterm"/>code in the <code class="literal">click</code> handler, however, which increments and displays the variable's value. Because a closure is created, the same instance of <code class="literal">counter</code> is referenced each time the link is clicked. This <a id="id1127" class="indexterm"/>means that the messages display a continuously <a id="id1128" class="indexterm"/>incrementing set of values, not just <code class="literal">1</code> each time:</p><div class="informalexample"><pre class="programlisting">counter = 1
counter = 2
counter = 3</pre></div><p>Event handlers can share their closing environments, just like other functions can:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var counter = 0;
  $('#button-1').click(function(event) {
    event.preventDefault();
    counter++;
    console.log('counter = ' + counter);
  });
<span class="strong"><strong>  $('#button-2').click(function(event) {</strong></span>
<span class="strong"><strong>    event.preventDefault();</strong></span>
<span class="strong"><strong>    counter--;</strong></span>
<span class="strong"><strong>    console.log('counter = ' + counter);</strong></span>
<span class="strong"><strong>  });</strong></span>
});</pre></div><p>
<span class="emphasis"><em>Listing A.12</em></span>
</p><p>Since both the functions <a id="id1129" class="indexterm"/>reference the same <code class="literal">counter</code> variable, the incrementing and decrementing operations of the two links affect the same value rather than being independent:</p><div class="informalexample"><pre class="programlisting">counter = 1
counter = 2
counter = 1
counter = 0</pre></div></div><div class="section" title="Binding handlers in loops"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec156"/>Binding handlers in loops</h2></div></div></div><p>Looping <a id="id1130" class="indexterm"/>constructs <a id="id1131" class="indexterm"/>can pose interesting <a id="id1132" class="indexterm"/>challenges due to the way closures operate. Consider a scenario in which we create elements in a loop and bind behaviors to those elements based on the loop's index:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  for (var i = 0; i &lt; 5; i++) {
    $('&lt;div&gt;Print ' + i + '&lt;/div&gt;')
      .click(function() {
        console.log(i);
      }).insertBefore('#results');
  }
});</pre></div><p>
<span class="emphasis"><em>Listing A.13</em></span>
</p><p>The variable <code class="literal">i</code> is set to the <a id="id1133" class="indexterm"/>numbers <code class="literal">0</code> through <code class="literal">4</code> in turn and a new <code class="literal">&lt;div&gt;</code> element is created each time. The elements each <a id="id1134" class="indexterm"/>have a unique text label as we would expect:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Print 0</strong></span>
<span class="strong"><strong>Print 1</strong></span>
<span class="strong"><strong>Print 2</strong></span>
<span class="strong"><strong>Print 3</strong></span>
<span class="strong"><strong>Print 4</strong></span>
</pre></div><p>We might anticipate that clicking <a id="id1135" class="indexterm"/>on an item would cause the corresponding number to be logged to the console. However, the <code class="literal">click</code> handlers always print the number <code class="literal">5</code> instead. Each <code class="literal">click</code> handler's reference to <code class="literal">i</code> is the same, even though the value of <code class="literal">i</code> is different at the time the handler is bound. The variable is the same one and so the final value of <code class="literal">i</code> (<code class="literal">5</code>) is fetched when the click actually happens.</p><p>We can get around this problem in a number of ways. First, we could replace the <code class="literal">for</code> loop with the <a id="id1136" class="indexterm"/>jQuery <code class="literal">$.each()</code> function:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
<span class="strong"><strong>  $.each([0, 1, 2, 3, 4], function(index, value) {</strong></span>
    $('&lt;div&gt;Print ' + value + '&lt;/div&gt;')
      .click(function() {
        console.log(value);
      }).insertBefore('#results');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing A.14</em></span>
</p><p>Function parameters are like variables defined within functions: the variable <code class="literal">value</code> is actually a different variable each time through the loop. Because of this, each <code class="literal">click</code> handler is pointing to a different <code class="literal">value</code> variable, which in turn means that <code class="literal">click</code> handlers on the elements print numbers corresponding to the element labels.</p><p>We can also exploit the same properties of function parameters to solve this problem without calling <a id="id1137" class="indexterm"/>
<code class="literal">$.each()</code>. Inside the <code class="literal">for</code> <a id="id1138" class="indexterm"/>loop, we can define and execute a new function that takes care of separating the values of <code class="literal">i</code> apart into distinct variables:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  for (var i = 0; i &lt; 5; i++) {
<span class="strong"><strong>    (function(value) {</strong></span>
      $('&lt;div&gt;Print ' + value + '&lt;/div&gt;')
        .click(function() {
          console.log(value);
        }).insertBefore('#results');
<span class="strong"><strong>    })(i);</strong></span>
  }
});</pre></div><p>
<span class="emphasis"><em>Listing A.15</em></span>
</p><p>In <a class="link" href="ch08.html" title="Chapter&#xA0;8.&#xA0;Developing Plugins">Chapter 8</a>, <span class="emphasis"><em>Developing Plugins</em></span>, <a id="id1139" class="indexterm"/>we were introduced to this construct, called an <span class="strong"><strong>immediately invoked function expression</strong></span> (<span class="strong"><strong>IIFE</strong></span>), as a means of redefining the <code class="literal">$</code> alias for the jQuery object after <code class="literal">$.noConflict()</code> has been called. Here, we use it to pass in <code class="literal">i</code> as a parameter named <code class="literal">value</code> <a id="id1140" class="indexterm"/>that is distinct for each <code class="literal">click</code> handler.</p><p>Finally, we can use a feature <a id="id1141" class="indexterm"/>of the jQuery event system to solve the problem a different way. The <code class="literal">.on()</code> method accepts an object parameter that is passed along to the <a id="id1142" class="indexterm"/>
<code class="literal">event</code> handler as <code class="literal">event.data</code>:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  for (var i = 0; i &lt; 5; i++) {
    $('&lt;div&gt;Print ' + i + '&lt;/div&gt;')
<span class="strong"><strong>      .on('click', {value: i}, function(event) {</strong></span>
<span class="strong"><strong>        console.log(event.data.value);</strong></span>
      }).insertBefore('#results');
  }
});</pre></div><p>
<span class="emphasis"><em>Listing A.16</em></span>
</p><p>In this case, <code class="literal">i</code> is provided as data to the <code class="literal">.on()</code> method and can be retrieved inside the handler by inspecting <code class="literal">event.data.value</code>. Once again, since <code class="literal">event</code> is a function parameter, it is a unique entity each time a handler is invoked.</p></div><div class="section" title="Giving names to functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec157"/>Giving names to functions</h2></div></div></div><p>These examples have used <a id="id1143" class="indexterm"/>anonymous functions, as has been our <a id="id1144" class="indexterm"/>custom in jQuery code. This makes no difference in the construction of closures; closures can come from named or anonymous functions. For example, we can write an anonymous function to report the index of an <code class="literal">&lt;input&gt;</code> <a id="id1145" class="indexterm"/>button within a jQuery object:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('input').each(function(index) {
    $(this).click(function(event) {
      event.preventDefault();
      console.log('index = ' + index);
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing A.17</em></span>
</p><p>Because the innermost function is defined within the <code class="literal">.each()</code> callback, this code actually creates as many functions as there are buttons. Each of these functions is attached as a <code class="literal">click</code> <a id="id1146" class="indexterm"/>handler to one of the buttons. The functions have <code class="literal">index</code> in their closing environment, since it is a <a id="id1147" class="indexterm"/>parameter to the <code class="literal">.each()</code> <a id="id1148" class="indexterm"/>callback. This behaves the same way as if the <code class="literal">click</code> <a id="id1149" class="indexterm"/>handler were written as a named function:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('input').each(function(index) {
<span class="strong"><strong>    function clickHandler(event) {</strong></span>
      event.preventDefault();
      console.log('index = ' + index);
    }

<span class="strong"><strong>    $(this).click(clickHandler);</strong></span>
  });
});</pre></div><p>
<span class="emphasis"><em>Listing A.18</em></span>
</p><p>The version with the anonymous function is just a bit shorter. The position of this named function is still relevant. The following code will trigger a JavaScript error whenever a button is clicked:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  function clickHandler(event) {
    event.preventDefault();
<span class="strong"><strong>    console.log('index = ' + index);</strong></span>
  }

<span class="strong"><strong>  $('input').each(function(index) {</strong></span>
    $(this).click(clickHandler);
  });
});</pre></div><p>
<span class="emphasis"><em>Listing A.19</em></span>
</p><p>The error is triggered because <a id="id1150" class="indexterm"/>
<code class="literal">index</code> is not found in the closing environment of <code class="literal">clickHandler()</code>. It remains a free variable, and so is undefined in this context.</p></div></div></body></html>
