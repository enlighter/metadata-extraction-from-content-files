<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Handling interactions between closures</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Handling interactions between closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec108"/>Handling interactions between closures</h1></div></div></div><p>When more than one inner function exists, <a id="id1115" class="indexterm"/>closures can have effects that are not as easy to anticipate. Suppose we pair our incrementing function with another function, this time incrementing by two:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
  var outerVar = 0;
  function innerFn1() {
    outerVar++;
    console.log('(1) outerVar = ' + outerVar);
  }
<span class="strong"><strong>  function innerFn2() {</strong></span>
<span class="strong"><strong>    outerVar += 2;</strong></span>
<span class="strong"><strong>    console.log('(2) outerVar = ' + outerVar);</strong></span>
<span class="strong"><strong>  }</strong></span>
  return {'fn1': innerFn1, 'fn2': innerFn2};
}
var fnRef = outerFn();
fnRef.fn1();
fnRef.fn2();
fnRef.fn1();
var fnRef2 = outerFn();
fnRef2.fn1();
fnRef2.fn2();
fnRef2.fn1();</pre></div><p>
<span class="emphasis"><em>Listing A.9</em></span>
</p><p>We return references to both functions, using an object to do so (this illustrates another way in which a reference to an inner <a id="id1116" class="indexterm"/>function can escape its parent). Both functions are called through the references:</p><div class="informalexample"><pre class="programlisting">(1) outerVar = 1
(2) outerVar = 3
(1) outerVar = 4
(1) outerVar = 1
(2) outerVar = 3
(1) outerVar = 4</pre></div><p>The two inner functions refer to the same local variable, so they share the same closing environment. When <code class="literal">innerFn1()</code> increments <code class="literal">outerVar</code> by <code class="literal">1</code>, this sets the new starting value of <code class="literal">outerVar</code> when <code class="literal">innerFn2()</code> is called and vice versa. Once again, we see that any subsequent call to <code class="literal">outerFn()</code> creates new instances of these closures with a new closing environment to match. Those familiar with object-oriented programming will note that we have in essence created a new object, with the free variables acting as instance variables and the closures acting as instance methods. The variables are also private, as they cannot be directly referenced outside of their enclosing scope, enabling true object-oriented data privacy.</p></div></body></html>
