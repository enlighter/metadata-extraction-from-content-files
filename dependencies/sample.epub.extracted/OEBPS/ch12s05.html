<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sorting and building rows with JSON</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Sorting and building rows with JSON"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec96"/>Sorting and building rows with JSON</h1></div></div></div><p>So far in this chapter, <a id="id986" class="indexterm"/>
<a id="id987" class="indexterm"/>we have been moving in the direction of outputting more and more information from the server into HTML so that our client-side scripts can remain as lean and efficient as possible. Now let's consider a different <a id="id988" class="indexterm"/>
<a id="id989" class="indexterm"/>scenario, one in which a whole new set of information is displayed when JavaScript is available. Increasingly, full-fledged web applications are relying on JavaScript to deliver content as well as manipulate it once it arrives. In our third table sorting example, we'll do the same.</p><p>We'll start by writing two functions: <a id="id990" class="indexterm"/>
<code class="literal">buildRow()</code>, which builds the HTML for a single table row, and <code class="literal">buildRows()</code>, which uses <code class="literal">$.map()</code> to loop through all of the rows in the dataset, calling <code class="literal">buildRow()</code> for each one:</p><div class="informalexample"><pre class="programlisting">function buildRow(row) {
  var authors = [];
  $.each(row.authors, function(index, auth) {
    authors[index] = auth.first_name + ' ' + auth.last_name;
  });
  var html = '&lt;tr&gt;';
    html += '&lt;td&gt;&lt;img src="images/' + row.img + '"&gt;&lt;/td&gt;';
    html += '&lt;td&gt;' + row.title + '&lt;/td&gt;';
    html += '&lt;td&gt;' + authors.join(', ') + '&lt;/td&gt;';
    html += '&lt;td&gt;' + row.published + '&lt;/td&gt;';
    html += '&lt;td&gt;$' + row.price + '&lt;/td&gt;';
  html += '&lt;/tr&gt;';
  return html;
}
function buildRows(rows) {
  var allRows = $.map(rows, buildRow);
  return allRows.join('');
}</pre></div><p>
<span class="emphasis"><em>Listing 12.9</em></span>
</p><p>For our purposes, we could get by with a single function to handle both tasks, but by using two separate functions, we leave open the possibility of building and inserting a single row at some other point. These functions will get their data from the response to an Ajax request:</p><div class="informalexample"><pre class="programlisting">$.getJSON('books.json', function(json) {
  $(document).ready(function() {
    var $table3 = $('#t-3');
    $table3.find('tbody').html(buildRows(json));
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 12.10</em></span>
</p><p>A few things are worth pointing out in this code. First, notice that the functions are defined outside of <code class="literal">$(document).ready()</code>. By waiting for the callback function of <code class="literal">$.getJSON()</code> to call <code class="literal">$(document).ready()</code>, we give the part of our code that doesn't rely on the DOM a head start.</p><p>Also worth noting is that we need to treat the <code class="literal">authors</code> data differently because it comes from the server as an <a id="id991" class="indexterm"/>
<a id="id992" class="indexterm"/>
<a id="id993" class="indexterm"/>
<a id="id994" class="indexterm"/>array of objects with <code class="literal">first_name</code> and <code class="literal">last_name</code> properties, while everything else arrives as a string or a number. We loop through the array of authors&#x2014;even though for most rows the array consists of only one&#x2014;and concatenate the first name and the last. After the <code class="literal">$.each()</code> loop, we join the array <a id="id995" class="indexterm"/>values with a comma and a space to end up with a nicely formatted list of names.</p><p>The <code class="literal">buildRow()</code> function <a id="id996" class="indexterm"/>assumes that the text we're getting from the JSON file is safe for consumption. Since we're concatenating <code class="literal">&lt;img&gt;</code>, <code class="literal">&lt;td&gt;</code>, and <code class="literal">&lt;tr&gt;</code> tags along with the text content into a single text string, we need to be sure that the text content has no unescaped <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, or <code class="literal">&amp;</code> characters. One <a id="id997" class="indexterm"/>
<a id="id998" class="indexterm"/>way to ensure HTML-safe strings is to process them on the server, converting all instances of <code class="literal">&lt;</code> to <code class="literal">&amp;lt;</code>, <code class="literal">&gt;</code> to <code class="literal">&amp;gt;</code>, and <code class="literal">&amp;</code> to <code class="literal">&amp;amp;</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Although we are lovingly crafting our table rows by hand with these two functions, JavaScript template systems such as Mustache (<a class="ulink" href="https://github.com/janl/mustache.js">https://github.com/janl/mustache.js</a>) and Handlebars (<a class="ulink" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>) could do a lot of the string processing and concatenation for us. Using templates can be especially beneficial as the size and complexity of a project grows.</p></div></div><div class="section" title="Modifying the JSON object"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec140"/>Modifying the JSON object</h2></div></div></div><p>The work we're doing <a id="id999" class="indexterm"/>with the <code class="literal">authors</code> array is fine if we only plan to call the <code class="literal">buildRows()</code> function once. However, since we intend to call it each time the rows are sorted, it's a good idea to have the author information formatted ahead of time. While we're at it, we can format the title and the author information for sorting as well. Unlike the second table, in which each row had sortable data in the <code class="literal">data-book</code> attribute and display data in the table cells, the JSON data we're retrieving for the third table comes in only one flavor. Still, by writing one more function, we can include modified values for sorting and displaying before we ever get to the table building functions:</p><div class="informalexample"><pre class="programlisting">function prepRows(rows) {
  $.each(rows, function(i, row) {
    var authors = [],
        authorsFormatted = [];
    rows[i].titleFormatted = row.title;
    rows[i].title = row.title.toUpperCase();
    $.each(row.authors, function(j, auth) {
      authors[j] = auth.last_name + ' ' + auth.first_name;
      authorsFormatted[j] = auth.first_name + ' '
      + auth.last_name;
    });
    rows[i].authorsFormatted = authorsFormatted.join(', ');
    rows[i].authors = authors.join(' ').toUpperCase();
  });
  return rows;
}</pre></div><p>
<span class="emphasis"><em>Listing 12.11</em></span>
</p><p>By passing our JSON data through this function, we add two properties to each row's object: <code class="literal">authorsFormatted</code> and <code class="literal">titleFormatted</code>. These properties will be used for the displayed table contents, preserving the original <code class="literal">authors</code> and <code class="literal">title</code> properties for sorting. The properties used for sorting are also converted to upper case to make the sort operation case insensitive.</p><p>When we call this <code class="literal">prepRows()</code> <a id="id1000" class="indexterm"/>function immediately inside the <code class="literal">$.getJSON()</code> callback <a id="id1001" class="indexterm"/>function, we store the returned value of the modified JSON object in the <code class="literal">rows</code> variable and use that one for sorting and <a id="id1002" class="indexterm"/>building. This means that we also need to change the <code class="literal">buildRow()</code> <a id="id1003" class="indexterm"/>function to take advantage of the simplicity that our advance preparation has afforded it:</p><div class="informalexample"><pre class="programlisting">function buildRow(row) {
  var html = '&lt;tr&gt;';
    html += '&lt;td&gt;&lt;img src="images/' + row.img + '"&gt;&lt;/td&gt;';
<span class="strong"><strong>    html += '&lt;td&gt;' + row.titleFormatted + '&lt;/td&gt;';</strong></span>
<span class="strong"><strong>    html += '&lt;td&gt;' + row.authorsFormatted + '&lt;/td&gt;';</strong></span>
    html += '&lt;td&gt;' + row.published + '&lt;/td&gt;';
    html += '&lt;td&gt;$' + row.price + '&lt;/td&gt;';
  html += '&lt;/tr&gt;';
  return html;
}
$.getJSON('books.json', function(json) {
  $(document).ready(function() {
    var $table3 = $('#t-3');
<span class="strong"><strong>    var rows = prepRows(json);</strong></span>
    $table3.find('tbody').html(buildRows(rows));
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 12.12</em></span>
</p></div><div class="section" title="Rebuilding content on demand"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec141"/>Rebuilding content on demand</h2></div></div></div><p>Now that we've prepared the <a id="id1004" class="indexterm"/>content for both sorting and displaying, we're ready to once again implement the column heading modification and the sorting routine:</p><div class="informalexample"><pre class="programlisting">$.getJSON('books.json', function(json) {
  $(document).ready(function() {
    var $table3 = $('#t-3');
    var rows = prepRows(json);
    $table3.find('tbody').html(buildRows(rows));
    var $headers = $table3.find('thead th').slice(1);
    $headers
      .wrapInner('&lt;a href="#"&gt;&lt;/a&gt;')
      .addClass('sort');
    $headers.on('click', function(event) {
      event.preventDefault();
      var $header = $(this),
          sortKey = $header.data('sort').key,
          sortDirection = 1;
      if ($header.hasClass('sorted-asc')) {
        sortDirection = -1;
      }
      rows.sort(function(a, b) {
<span class="strong"><strong>        var keyA = a[sortKey];</strong></span>
<span class="strong"><strong>        var keyB = b[sortKey];</strong></span>
        if (keyA &lt; keyB) return -sortDirection;
        if (keyA &gt; keyB) return sortDirection;
        return 0;
      });
      $headers.removeClass('sorted-asc sorted-desc');
      $header.addClass(sortDirection == 1 ? 'sorted-asc' : 'sorted-desc');
<span class="strong"><strong>      $table3.children('tbody').html(buildRows(rows));</strong></span>
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 12.13</em></span>
</p><p>The code inside the <code class="literal">click</code>
<a id="id1005" class="indexterm"/> handler is nearly identical to the handler for the second table in <span class="emphasis"><em>Listing 12.8</em></span>. The one notable difference is that here we insert elements into the DOM only once per sort. In tables one and <a id="id1006" class="indexterm"/>two, even after our other optimizations, we sorted the actual DOM elements and then looped through them one-by-one, appending each one in turn to arrive at the new order. For example, in <span class="emphasis"><em>Listing 12.8</em></span>, table rows are reinserted in a loop like so:</p><div class="informalexample"><pre class="programlisting">$.each(rows, function(index, row) {
  $table2.children('tbody').append(row);
});</pre></div><p>This type of repetitive DOM insertion can be quite costly from a performance perspective, especially with a large number of rows. Compare that with our latest approach in <span class="emphasis"><em>Listing 12.13</em></span>:</p><div class="informalexample"><pre class="programlisting">$table3.children('tbody').html(buildRows(rows));</pre></div><p>The <code class="literal">buildRows()</code> function returns a string of HTML representing the rows and inserts it in one fell swoop, replacing the rows instead of moving the existing ones around.</p></div></div></body></html>
