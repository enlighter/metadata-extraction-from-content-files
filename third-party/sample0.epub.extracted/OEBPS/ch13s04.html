<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Throttling Ajax requests</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Throttling Ajax requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec103"/>Throttling Ajax requests</h1></div></div></div><p>An increasingly common <a id="id1067" class="indexterm"/>feature of searches is to display a dynamic list of results as the user is typing. We can emulate this "live search" feature for our jQuery API search by binding a handler to the <code class="literal">keyup</code> event:</p><div class="informalexample"><pre class="programlisting">$('#title').on('keyup', function(event) {
  $ajaxForm.triggerHandler('submit');
});</pre></div><p>
<span class="emphasis"><em>Listing 13.10</em></span>
</p><p>Here, we simply trigger the form's submit handler whenever the user types something in the <span class="strong"><strong>Search</strong></span> field. This could have the effect of sending many requests across the network in rapid succession, depending on the speed at which the user types. This behavior could bog down JavaScript's performance; it could clog the network connection, and the server might not be able to handle that kind of demand.</p><p>We're already limiting the number of requests with the request caching that we've just put in place. We can further ease the burden on the server, however, by throttling the requests. In <a class="link" href="ch10.html" title="Chapter&#xA0;10.&#xA0;Advanced Events">Chapter 10</a>, <span class="emphasis"><em>Advanced Events</em></span>, we introduced the concept of throttling when we created a special <code class="literal">throttledScroll</code> event to reduce the number of times the native scroll event is fired. In this case, we want to make a similar reduction in activity; this time with the <code class="literal">keyup</code> event:</p><div class="informalexample"><pre class="programlisting">var searchTimeout,
    searchDelay = 300;

$('#title').on('keyup', function(event) {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(function() {
    $ajaxForm.triggerHandler('submit');
  }, searchDelay);
});</pre></div><p>
<span class="emphasis"><em>Listing 13.11</em></span>
</p><p>Our technique here, sometimes referred to as debouncing, is a bit different from the one we used in <a class="link" href="ch10.html" title="Chapter&#xA0;10.&#xA0;Advanced Events">Chapter 10</a>, <span class="emphasis"><em>Advanced Events</em></span>. Whereas in that example we needed our <code class="literal">scroll</code> handler to take effect multiple times as scrolling continued; here we only need the <code class="literal">keyup</code> behavior to happen one time after typing has ceased. To do this, we keep track of a JavaScript timer that starts whenever the user presses a key. Each keystroke resets that timer, so only once the user stops typing for the designated amount of time (300 milliseconds) does the <code class="literal">submit</code> handler get triggered and the Ajax request performed.</p></div></body></html>
