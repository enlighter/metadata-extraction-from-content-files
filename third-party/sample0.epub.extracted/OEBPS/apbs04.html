<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Adding and running tests</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Adding and running tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec115"/>Adding and running tests</h1></div></div></div><p>In <span class="strong"><strong>test-driven development</strong></span>, we <a id="id1174" class="indexterm"/>
<a id="id1175" class="indexterm"/>write tests before writing code. This way, we can observe when a test fails, add new code, and then see that the test passes, verifying that our change has the intended effect.</p><p>Let's start by testing the child selector that we used in <a class="link" href="ch02.html" title="Chapter&#xA0;2.&#xA0;Selecting Elements">Chapter 2</a>, <span class="emphasis"><em>Selecting Elements</em></span>, to add a <code class="literal">horizontal</code> class to all <code class="literal">&lt;li&gt;</code> elements that are children of <code class="literal">&lt;ul id="selected-plays"&gt;</code>:</p><div class="informalexample"><pre class="programlisting">test('Child Selector', function() {
  expect(1);
  var topLis = $('#selected-plays &gt; li.horizontal');
  equal(topLis.length, 3, 'Top LIs have horizontal class');
});</pre></div><p>
<span class="emphasis"><em>Listing B.2</em></span>
</p><p>Here we've actually introduced two tests. We <a id="id1176" class="indexterm"/>begin with the <code class="literal">expect()</code> test, which tells QUnit how many tests we expect to run in this set. Then, because we're testing our ability to <a id="id1177" class="indexterm"/>select elements on the page, we use the <code class="literal">equal()</code> test to compare the number of top-level <code class="literal">&lt;li&gt;</code> elements against the number <code class="literal">3</code>. If the two are equal, the test is successful and is added to the number of passed tests. If not, the test fails:</p><div class="mediaobject"><img src="graphics/3145OS_AppB_02.jpg" alt="Adding and running tests"/></div><p>Of course, the test fails because we have <a id="id1178" class="indexterm"/>not yet written the code to add the <code class="literal">horizontal</code> class. It is simple to add that code, though. We do so in the main script file for the page, which we called <code class="literal">B.js</code>:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#selected-plays &gt; li').addClass('horizontal');
});</pre></div><p>
<span class="emphasis"><em>Listing B.3</em></span>
</p><p>When we<a id="id1179" class="indexterm"/> run the <a id="id1180" class="indexterm"/>test now, it gives the result in the following screenshot:</p><div class="mediaobject"><img src="graphics/3145OS_AppB_03.jpg" alt="Adding and running tests"/></div><p>Now the <span class="strong"><strong>Selecting: Child Selector</strong></span> test shows the numbers <span class="strong"><strong>0, 1, 1</strong></span> in parentheses, indicating that no tests failed, one test passed, and the total number of tests is one. We can take the testing a step further now by adding a couple of attribute selector tests:</p><div class="informalexample"><pre class="programlisting">module('Selecting', {
  setup: function() {
    this.topLis = $('#selected-plays &gt; li.horizontal');
  }
});
test('Child Selector', function() {
  expect(1);
  equal(this.topLis.length, 3, 
    'Top LIs have horizontal class');
});
<span class="strong"><strong>test('Attribute Selectors', function() {</strong></span>
<span class="strong"><strong>  expect(2);</strong></span>
<span class="strong"><strong>  ok(this.topLis.find('.mailto').length == 1, 'a.mailto');</strong></span>
<span class="strong"><strong>  equal(this.topLis.find('.pdflink').length, 1, 'a.pdflink');</strong></span>
<span class="strong"><strong>});</strong></span>
</pre></div><p>
<span class="emphasis"><em>Listing B.4</em></span>
</p><p>Here we've introduced another type of test: <code class="literal">ok()</code>. This one takes two arguments: an expression that should evaluate to <code class="literal">true</code> if successful, and a description. Also note that we've moved the local <code class="literal">topLis</code> variable out of the <span class="strong"><strong>Child Selector</strong></span> test, where it was in <span class="emphasis"><em>Listing B.2</em></span>, and into the module's <a id="id1181" class="indexterm"/>
<code class="literal">setup()</code> callback function. The <code class="literal">module()</code> function takes an optional second argument, which is a plain object that can include a <code class="literal">setup()</code> and a <code class="literal">teardown()</code> function. Within these <a id="id1182" class="indexterm"/>
<a id="id1183" class="indexterm"/>functions, we can use the <code class="literal">this</code> keyword to assign variables once for all of a module's tests.</p><p>Again, the new tests will fail without corresponding working code:</p><div class="mediaobject"><img src="graphics/3145OS_appB_04.jpg" alt="Adding and running tests"/></div><p>Here we can see the difference in test failure output between the <code class="literal">ok()</code> test, which only shows the test's label (<span class="strong"><strong>a.mailto</strong></span>) and source, and the <code class="literal">equal()</code> test, which also details the expected result. Because it provides more information for test failures, the <code class="literal">equal()</code> test is typically preferred over the <code class="literal">ok()</code> test.</p><p>Let's include the necessary code:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#selected-plays &gt; li').addClass('horizontal');
<span class="strong"><strong>  $('a[href^="mailto:"]').addClass('mailto');</strong></span>
<span class="strong"><strong>  $('a[href$=".pdf"]').addClass('pdflink');</strong></span>
});</pre></div><p>
<span class="emphasis"><em>Listing B.5</em></span>
</p><p>The two tests now pass, as we can see by expanding the set:</p><div class="mediaobject"><img src="graphics/3145OS_AppB_05.jpg" alt="Adding and running tests"/></div><p>Although on failure the <code class="literal">equal()</code> <a id="id1184" class="indexterm"/>test presented more information than the <code class="literal">ok()</code> test, on success both tests simply display the label.</p><div class="section" title="Asynchronous testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec160"/>Asynchronous testing</h2></div></div></div><p>Testing asynchronous <a id="id1185" class="indexterm"/>code such as Ajax requests presents an additional <a id="id1186" class="indexterm"/>challenge. The rest of the tests must pause while the asynchronous test occurs, and then they must begin again when it is complete. This type of scenario is by now very familiar; we have seen such asynchronous operations in effects queues, Ajax callback functions, and promise objects. In QUnit, we use a special test set called <code class="literal">asyncTest()</code>. <a id="id1187" class="indexterm"/>It looks just like the regular <code class="literal">test()</code> set except that it will pause the running of tests until we resume them with a call to the special <code class="literal">start()</code> function:</p><div class="informalexample"><pre class="programlisting">asyncTest('JSON', function() {
  $.getJSON('b.json', function(json, textStatus) {
    // add tests here
  }).always(function() {
    start();
  });
});</pre></div><p>
<span class="emphasis"><em>Listing B.6</em></span>
</p><p>Here we're simply requesting JSON from <code class="literal">b.json</code> and allowing the tests to continue once the request has completed, whether it succeeds or fails, by calling <code class="literal">start()</code> inside the <code class="literal">.always()</code> callback function. <a id="id1188" class="indexterm"/>For the actual tests, we're going to check the <code class="literal">textStatus</code> value to ensure that the request is successful and check the value of one of the objects within the response JSON array:</p><div class="informalexample"><pre class="programlisting">asyncTest('JSON', function() {
  expect(2);
  var backbite = {
    "term": "BACKBITE",
    "part": "v.t.",
    "definition": "To speak of a man as you find him when he can't find you."
  };
  $.getJSON('b.json', function(json, textStatus) {
<span class="strong"><strong>    equal(textStatus, 'success', 'Request successful');</strong></span>
<span class="strong"><strong>    deepEqual(json[1], backbite,</strong></span>
<span class="strong"><strong>      'result array matches "backbite" map');</strong></span>
  }).always(function() {
    start();
  });
});</pre></div><p>
<span class="emphasis"><em>Listing B.7</em></span>
</p><p>For testing the response value, we use yet <a id="id1189" class="indexterm"/>another test function: <code class="literal">deepEqual()</code>. Normally when two objects are compared, they are considered not equal unless they actually refer to the same location in memory. If we want to compare the object contents instead, <code class="literal">deepEqual()</code> meets the need. This <a id="id1190" class="indexterm"/>function walks through two objects to ensure that they have the same properties and that those properties have the same values.</p></div></div></body></html>
