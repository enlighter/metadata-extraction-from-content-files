<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Customizing and optimizing selectors</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Customizing and optimizing selectors"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Customizing and optimizing selectors</h1></div></div></div><p>The many techniques we've <a id="id740" class="indexterm"/>
<a id="id741" class="indexterm"/>seen give us a tool chest that can be used to find any page element we want to work with. The story doesn't end here though; there is much to learn about performing our element-finding tasks efficiently. This efficiency can take the form of both code that is easier to write and read, and code that executes more quickly inside the web browser.</p><div class="section" title="Writing a custom selector plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec109"/>Writing a custom selector plugin</h2></div></div></div><p>One way to improve legibility <a id="id742" class="indexterm"/>is to encapsulate code snippets in reusable components. We do this all the time by creating functions. In <a class="link" href="ch08.html" title="Chapter&#xA0;8.&#xA0;Developing Plugins">Chapter 8</a>, <span class="emphasis"><em>Developing Plugins</em></span>, we expanded this idea by crafting jQuery plugins that added methods to jQuery objects. This isn't the only way plugins can help us reuse code, though. Plugins can also provide additional selector expressions, such as the <code class="literal">:paused</code> selector that Cycle gave us in <a class="link" href="ch07.html" title="Chapter&#xA0;7.&#xA0;Using Plugins">Chapter 7,</a> 
<span class="emphasis"><em>Using Plugins</em></span>.</p><p>The easiest type of selector expression to add is a <a id="id743" class="indexterm"/>
<span class="strong"><strong>pseudo-class</strong></span>. This is an expression that starts with a colon, such as <code class="literal">:checked</code> or <code class="literal">:nth-child()</code>. To illustrate the process of creating a selector expression, we'll build a pseudo-class called <code class="literal">:group()</code>. This new selector will encapsulate the code we used to find table rows to stripe back in <span class="emphasis"><em>Listing 9.6</em></span>.</p><p>When using a selector expression to find elements, jQuery looks for instructions in an internal object called <code class="literal">expr</code>. <a id="id744" class="indexterm"/>The <a id="id745" class="indexterm"/>values in this object behave much like the filtering functions that we pass to <code class="literal">.filter()</code> or <code class="literal">.not()</code>, containing JavaScript code that causes each element to be contained in the result set if and only if the function returns <code class="literal">true</code>. We can add new expressions to this object using the <a id="id746" class="indexterm"/>
<code class="literal">$.extend()</code> function:</p><div class="informalexample"><pre class="programlisting">(function($) {
  $.extend($.expr[':'], {
    group: function(element, index, matches, set) {
      var num = parseInt(matches[3], 10);
      if (isNaN(num)) {
        return false;
      }
      return index % (num * 2) &lt;num;
    }
  });
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 9.8</em></span>
</p><p>This code tells jQuery that <code class="literal">group</code> is a valid string that can follow a colon in a selector expression, and that when it is encountered, the given function should be called to determine whether the element should be included in the result set.</p><p>The function that is evaluated here is passed four parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">element</code>: The DOM <a id="id747" class="indexterm"/>element under consideration. This is needed for most selectors, but not ours.</li><li class="listitem" style="list-style-type: disc"><code class="literal">index</code>: The index of the <a id="id748" class="indexterm"/>DOM element within the result set.</li><li class="listitem" style="list-style-type: disc"><code class="literal">matches</code>: An array containing <a id="id749" class="indexterm"/>the result of the regular expression that was used to parse this selector. Typically, <code class="literal">matches[3]</code> is the only relevant item in the array; in a selector of the form <code class="literal">:group(2)</code>, the <code class="literal">matches[3]</code> item contains <code class="literal">2</code>, the text within the parentheses.</li><li class="listitem" style="list-style-type: disc"><code class="literal">set</code>: The entire set of <a id="id750" class="indexterm"/>DOM elements matched up to this point. This parameter is rarely needed.</li></ul></div><p>Pseudo-class selectors need to use the information contained in these four arguments to determine whether or not the element belongs in the result set. In this case, <code class="literal">index</code> and <code class="literal">matches</code> are all that we require.</p><p>With the new <code class="literal">:group</code> selector, we now have a flexible way to select alternating groups of elements. For example, we could combine the selector expression and <code class="literal">.filter()</code> function from <span class="emphasis"><em>Listing 9.5</em></span> into a single selector expression: <code class="literal">$('#news tr:group(2)')</code>. Or we could preserve the per-section behavior from <span class="emphasis"><em>Listing 9.7</em></span>, and use <code class="literal">:group()</code> as an expression within a <code class="literal">.filter()</code> call. We can even change the number of rows to group by simply changing the <a id="id751" class="indexterm"/>number within the parentheses:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  function stripe() {
    $('#news').find('tr.alt').removeClass('alt');
    $('#news tbody').each(function() {
      $(this).children(':visible').has('td')
<span class="strong"><strong>      .filter(':group(3)').addClass('alt');</strong></span>
    });
  }
  stripe();
});</pre></div><p>
<span class="emphasis"><em>Listing 9.9</em></span>
</p><p>Now we can see that the row striping alternates by groups of three:</p><div class="mediaobject"><img src="graphics/3145OS_09_06.jpg" alt="Writing a custom selector plugin"/></div></div><div class="section" title="Selector performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec110"/>Selector performance</h2></div></div></div><p>In planning any web <a id="id752" class="indexterm"/>development project, we need to keep in mind the time it takes to create the site, the ease and speed with which we can maintain our code, and the performance of the site as users interact with it. Often the first two of these concerns are more important than the third. Especially with client-side scripting, developers can easily fall into the traps of <a id="id753" class="indexterm"/>
<span class="strong"><strong>premature optimization</strong></span> and <a id="id754" class="indexterm"/>
<span class="strong"><strong>micro-optimization</strong></span>. These pitfalls can cause us to spend countless hours tweaking our code to shave milliseconds off of JavaScript execution time, even when there was no noticeable performance lag in the first place.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip52"/>Tip</h3><p>A good rule of thumb is to consider developers' time more valuable than the computer's time, unless we notice slowness in our application.</p></div></div><p>Even when performance is an issue, pinpointing the bottlenecks in our jQuery code can be difficult. As we hinted at earlier in this chapter, some selectors are generally faster than others, and moving part of a selector to a traversal method can help speed up the time it takes to find elements on the page. Selector and traversal performance is therefore often a good place to start examining our code to reduce the amount of delay that users may experience <a id="id755" class="indexterm"/>when interacting with the page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip53"/>Tip</h3><p>Any decrees made about the relative speed of selectors and traversal methods are likely to become outdated with the release of newer, faster browsers and clever speed tweaks introduced in newer jQuery versions. In matters of performance, it is a good idea to routinely question our assumptions and to optimize code after performing measurements <a id="id756" class="indexterm"/>using a tool such as jsPerf (<a class="ulink" href="http://jsperf.com">http://jsperf.com</a>).</p></div></div><p>With this in mind, we'll examine a couple of simple guidelines for producing optimized jQuery selector code.</p><div class="section" title="The Sizzle selector implementation"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec22"/>The Sizzle selector implementation</h3></div></div></div><p>As noted in the beginning <a id="id757" class="indexterm"/>of this chapter, when we pass a selector expression into the <code class="literal">$()</code> function, jQuery's Sizzle implementation parses the expression and determines how to gather the elements represented by it. In its basic form, <a id="id758" class="indexterm"/>Sizzle applies the most efficient native <span class="strong"><strong>DOM method</strong></span> that the browser supports to obtain a <code class="literal">nodeList</code>, a native array-like object of DOM elements that jQuery ultimately converts to a true array and adds to the <code class="literal">jQuery</code> object. The following is a list of DOM methods that jQuery uses internally, along with the recent browser versions that support them:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Selects</p>
</th><th style="text-align: left" valign="bottom">
<p>Supported by</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.getElementById()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id759" class="indexterm"/>unique element with an ID that matches the given string</p>
</td><td style="text-align: left" valign="top">
<p>All browsers</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.getElementsByTagName()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>All elements <a id="id760" class="indexterm"/>with a tag name that matches the given string.</p>
</td><td style="text-align: left" valign="top">
<p>All browsers</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.getElementsByClassName()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>All elements <a id="id761" class="indexterm"/>that have one of their class names matching the given string.</p>
</td><td style="text-align: left" valign="top">
<p>IE9+, Firefox 3+, Safari 4+, Chrome 4+, and Opera 10+</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.querySelectorAll()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>All <a id="id762" class="indexterm"/>elements that match the given selector expression.</p>
</td><td style="text-align: left" valign="top">
<p>IE8+, Firefox 3.5+, Safari 3+, Chrome 4+, and Opera 10+</p>
</td></tr></tbody></table></div><p>If a part of the selector expression cannot be handled by one of these methods, Sizzle falls back to looping through each element that has already been collected and testing each one against the expression part. If <span class="emphasis"><em>no</em></span> part of the selector expression can be handled by a DOM method, Sizzle starts with a collection of <span class="emphasis"><em>all</em></span> elements in the document, represented by <code class="literal">document.getElementsByTagName('*')</code>, and loops through each one in turn.</p><p>This looping and testing of each element is much more costly in terms of performance than any of the native DOM methods. Fortunately, the most recent versions of all modern desktop browsers include the native <code class="literal">.querySelectorAll()</code> method, and Sizzle uses it when it can't use the other even speedier native methods&#x2014;with one exception. When the selector expression contains a custom <a id="id763" class="indexterm"/>jQuery selector such as <code class="literal">:eq()</code> or <code class="literal">:odd</code> or <code class="literal">:even</code> that has no CSS counterpart, <a id="id764" class="indexterm"/>Sizzle has no choice but to loop and test.</p></div><div class="section" title="Testing selector speed"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec23"/>Testing selector speed</h3></div></div></div><p>To get an idea of the performance <a id="id765" class="indexterm"/>difference between <code class="literal">.querySelectorAll()</code> and the "loop-and-test" procedure, consider a document in which we wish to select all the <code class="literal">&lt;input type="text"&gt;</code> elements. We could write the selector expression in one of two ways: <code class="literal">$('input[type="text"]')</code>, which uses a CSS attribute selector, and <code class="literal">$('input:text')</code>, which uses a custom jQuery selector. To test just the portions of the selectors we are interested in here, we will remove the <code class="literal">input</code> parts and compare the speeds of <code class="literal">$('[type="text"]')</code> and <code class="literal">$(':text')</code>. The JavaScript benchmarking site <a class="ulink" href="http://jsperf.com/">http://jsperf.com/</a> lets us make this comparison, yielding dramatic results.</p><p>In jsPerf tests, each test case is cycled to see how many times it can be completed in a certain amount of time, so the higher the number, the better. When tested in modern browsers that support <code class="literal">.querySelectorAll()</code> (Chrome 26, Firefox 20, and Safari 6), the selector that can take advantage of it is remarkably faster than the custom jQuery selector:</p><div class="mediaobject"><img src="graphics/3145OS_09_07.jpg" alt="Testing selector speed"/><div class="caption"><p>Figure 9.1</p></div></div><p>However, in a browser that does not support <code class="literal">.querySelectorAll()</code>, such as IE 7, the two selectors perform almost <a id="id766" class="indexterm"/>identically. In this case, both selectors force jQuery to loop through every element on the page and test each one individually:</p><div class="mediaobject"><img src="graphics/3145OS_09_08.jpg" alt="Testing selector speed"/><div class="caption"><p>Figure 9.2</p></div></div><p>The performance difference <a id="id767" class="indexterm"/>between a selector that uses a native method and one that doesn't is also apparent when we look at <code class="literal">$('input:eq(1)')</code> and <code class="literal">$('input').eq(1)</code>:</p><div class="mediaobject"><img src="graphics/3145OS_09_09.jpg" alt="Testing selector speed"/><div class="caption"><p>Figure 9.3</p></div></div><p>While the raw number of operations per second varies greatly from browser to browser, all of the tested browsers show a significant performance boost when we move the custom <code class="literal">:eq()</code> selector out into the <a id="id768" class="indexterm"/>
<code class="literal">.eq()</code> method. Using the simple <code class="literal">input</code> tag name as the argument for the <code class="literal">$()</code> function allows for a quick lookup, and the <code class="literal">.eq()</code> method then simply calls an array function to retrieve the second element in the jQuery collection.</p><p>As a general rule of thumb, we should <a id="id769" class="indexterm"/>prefer selectors that are part of the CSS specification over jQuery's custom selectors whenever possible. Still, before changing our selectors, it makes sense to first confirm that there is a need to increase performance, and then test just how much the change would boost performance with a benchmarking tool such as <a class="ulink" href="http://jsperf.com">http://jsperf.com</a>.</p></div></div></div></body></html>
