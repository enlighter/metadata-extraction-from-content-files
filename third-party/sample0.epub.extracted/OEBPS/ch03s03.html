<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Event propagation</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Event propagation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Event propagation</h1></div></div></div><p>In illustrating the ability of the <code class="literal">click</code> event to operate on normally non-clickable page elements, we have crafted an <a id="id208" class="indexterm"/>interface that gives few hints that the style switcher label&#x2014;actually just an <code class="literal">&lt;h3&gt;</code> element&#x2014;is actually a <span class="emphasis"><em>live</em></span> part of the page awaiting user interaction. To remedy this, we can give it a rollover state, making it clear that it interacts in some way with the mouse:</p><div class="informalexample"><pre class="programlisting">.hover {
  cursor: pointer;
  background-color: #afa;
}</pre></div><p>The CSS specification includes a pseudo-class called <code class="literal">:hover</code>, which allows a stylesheet to affect an element's appearance when the user's mouse cursor hovers over it. This would certainly solve our problem in this instance, but instead, we will take this opportunity to introduce jQuery's <code class="literal">.hover()</code> method, <a id="id209" class="indexterm"/>which allows us to use JavaScript to change an element's styling&#x2014;and indeed, perform any arbitrary action&#x2014;both when the mouse cursor enters the element and when it leaves the element.</p><p>The <code class="literal">.hover()</code> method takes two <a id="id210" class="indexterm"/>function arguments, unlike the simple event methods we have so far encountered. The first function will be executed when the mouse cursor enters the selected element, and the second is fired when the cursor leaves. We can modify the classes applied to the buttons at these times to achieve a rollover effect:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#switcher h3').hover(function() {
    $(this).addClass('hover');
  }, function() {
    $(this).removeClass('hover');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 3.10</em></span>
</p><p>We once again use implicit iteration and event context for short and simple code. Now when hovering over the <code class="literal">&lt;h3&gt;</code> element, we see our class applied:</p><div class="mediaobject"><img src="graphics/3145OS_03_06.jpg" alt="Event propagation"/></div><p>The use of <code class="literal">.hover()</code> also means we avoid headaches caused by event propagation in JavaScript. To understand this, we need <a id="id211" class="indexterm"/>to take a look at how JavaScript decides which element gets to handle a given event.</p><div class="section" title="The journey of an event"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>The journey of an event</h2></div></div></div><p>When an event occurs on a <a id="id212" class="indexterm"/>page, an entire hierarchy of DOM elements gets a chance to handle the event. Consider a page model like the following:</p><div class="informalexample"><pre class="programlisting">&lt;div class="foo"&gt;
  &lt;span class="bar"&gt;
    &lt;a href="http://www.example.com/"&gt;
      The quick brown fox jumps over the lazy dog.
    &lt;/a&gt;
  &lt;/span&gt;
  &lt;p&gt;
    How razorback-jumping frogs can level six piqued gymnasts!
  &lt;/p&gt;
&lt;/div&gt;</pre></div><p>We then visualize the code as a set of nested elements:</p><div class="mediaobject"><img src="graphics/3145OS_03_07.jpg" alt="The journey of an event"/></div><p>For any event, there are multiple elements that could logically be responsible for reacting. When the link on this page is clicked, for example, the <code class="literal">&lt;div&gt;</code>, <code class="literal">&lt;span&gt;</code>, and <code class="literal">&lt;a&gt;</code> elements should all get the opportunity to respond to the click. After all, these three elements are all under the user's mouse cursor at the time. The <code class="literal">&lt;p&gt;</code> element, on the other hand, is not part of this interaction at all.</p><p>One strategy for allowing multiple elements to respond to a user interaction is called <span class="strong"><strong>event capturing</strong></span>. With <a id="id213" class="indexterm"/>event <a id="id214" class="indexterm"/>capturing, the event is first given to the most all-encompassing element, and then to progressively more specific ones. In our example, this means that first the <code class="literal">&lt;div&gt;</code> element gets passed the event, then the <code class="literal">&lt;span&gt;</code> element, and finally the <code class="literal">&lt;a&gt;</code> element, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/3145OS_03_08.jpg" alt="The journey of an event"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Technically, in browser implementations of event capturing, specific elements register to listen for events that occur among their descendants. The approximation provided here is close enough for our needs.</p></div></div><p>The opposite strategy is called <span class="strong"><strong>event </strong></span>
<a id="id215" class="indexterm"/>
<span class="strong"><strong>bubbling</strong></span>. The event gets sent to the most specific element, and after this element has an opportunity to react, the event <span class="strong"><strong>bubbles up</strong></span> to more <a id="id216" class="indexterm"/>general elements. In our example, the <code class="literal">&lt;a&gt;</code> element would be handed the event first, and then the <code class="literal">&lt;span&gt;</code> and <code class="literal">&lt;div&gt;</code> elements in that order, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/3145OS_03_09.jpg" alt="The journey of an event"/></div><p>Unsurprisingly, different browser developers originally decided on different models for event propagation. The DOM standard that was eventually developed thus specified that both strategies should be used: first the event is captured from general elements to specific ones, and then the event bubbles back up to the top of the DOM tree. Event handlers can be registered for either part of the process.</p><p>To provide consistent and easy-to-understand <a id="id217" class="indexterm"/>behavior, jQuery always registers event handlers for the bubbling phase of the model. We can always assume that the most specific element will get the first opportunity to respond to any event.</p></div><div class="section" title="Side effects of event bubbling"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Side effects of event bubbling</h2></div></div></div><p>Event bubbling can cause <a id="id218" class="indexterm"/>unexpected behavior, especially when the wrong element responds to a <code class="literal">mouseover</code> or <code class="literal">mouseout</code> event. Consider a <code class="literal">mouseout</code> event handler <a id="id219" class="indexterm"/>attached to the <code class="literal">&lt;div&gt;</code> element in our example. When the user's mouse cursor exits the <code class="literal">&lt;div&gt;</code> element, the <code class="literal">mouseout</code> handler is run as anticipated. Since this is at the top of the hierarchy, no other elements get the event. On the other hand, when the cursor exits the <code class="literal">&lt;a&gt;</code> element, a <code class="literal">mouseout</code> event is sent to that. This event will then bubble up to the <code class="literal">&lt;span&gt;</code> element and then to the <code class="literal">&lt;div&gt;</code> element, firing the same event handler. This bubbling sequence is likely not desired.</p><p>The <code class="literal">mouseenter</code> and <a id="id220" class="indexterm"/>
<code class="literal">mouseleave</code> <a id="id221" class="indexterm"/>events, either bound individually or combined in the <code class="literal">.hover()</code> method, are aware of these bubbling issues, and when we use them to attach events, we can ignore the problems caused by the wrong element getting a <code class="literal">mouseover</code> or <code class="literal">mouseout</code> event.</p><p>The <code class="literal">mouseout</code> scenario just described illustrates the need to constrain the scope of an event. While <code class="literal">.hover()</code> handles <a id="id222" class="indexterm"/>this specific case, we will encounter other situations in which we need to limit an event spatially (preventing the event from being sent to certain elements) or temporally (preventing <a id="id223" class="indexterm"/>the event from being sent at certain times).</p></div></div></body></html>
