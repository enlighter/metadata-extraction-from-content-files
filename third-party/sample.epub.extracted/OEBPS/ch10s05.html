<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Extending events</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Extending events"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>Extending events</h1></div></div></div><p>Some events, such as <code class="literal">mouseenter</code> and <code class="literal">ready</code>, are designated as <span class="strong"><strong>special events</strong></span> by the jQuery internals. These events use <a id="id866" class="indexterm"/>the elaborate event extension framework offered by jQuery. Such events get the opportunity to take action at various times in the life cycle of an event handler. They may react to handlers being bound or unbound, and they can even have preventable default behaviors like clicked links or submitted forms do. The event extension API lets us create sophisticated new events that act much like native DOM events.</p><p>The throttling behavior we implemented for scrolling in <span class="emphasis"><em>Listing 10.13</em></span> is useful, and we may want to generalize it for use in other projects. <a id="id867" class="indexterm"/>We can accomplish this by creating a new event that encapsulates the throttling technique within the special event hooks.</p><p>To implement special behavior for an event, we add a property to the <code class="literal">$.event.special</code> object. This added property, <a id="id868" class="indexterm"/>which is itself an object, has our event name as its key. It can contain callbacks called at many different specific times in an event's life cycle, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">add</code> is called every time a handler <a id="id869" class="indexterm"/>for this event is bound</li><li class="listitem" style="list-style-type: disc"><code class="literal">remove</code> is called every time a <a id="id870" class="indexterm"/>handler for the event is unbound</li><li class="listitem" style="list-style-type: disc"><code class="literal">setup</code> is called when a handler <a id="id871" class="indexterm"/>is bound for the event, but only if no other handlers for that event are bound to the element</li><li class="listitem" style="list-style-type: disc"><code class="literal">teardown</code> is the converse of <a id="id872" class="indexterm"/><code class="literal">setup</code>, called when the last handler for the event is unbound from an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">_default</code> becomes the default <a id="id873" class="indexterm"/>behavior of the event, called unless the default action is prevented by an event handler</li></ul></div><p>These callbacks can be used in some very creative ways. A fairly common scenario, which we'll explore in our example code, is to automatically trigger the event in response to some browser condition. It would be wasteful to monitor the state and trigger events if no handlers are listening for the event, so we can use the <code class="literal">setup </code>callback to initiate this work only when needed:</p><div class="informalexample"><pre class="programlisting">(function($) {
  $.event.special.throttledScroll = {
    setup: function(data) {
      var timer = 0;
      $(this).on('scroll.throttledScroll', function(event) {
        if (!timer) {
          timer = setTimeout(function() {
            $(this).triggerHandler('throttledScroll');
            timer = 0;
          }, 250);
        }
      });
    },
    teardown: function() {
      $(this).off('scroll.throttledScroll');
    }
  };
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 10.16</em></span>
</p><p>For our scroll throttling event, we need to bind a regular <code class="literal">scroll</code> handler that uses the same <code class="literal">setTimeout</code> technique as the <a id="id874" class="indexterm"/>one we developed in <span class="emphasis"><em>Listing 10.14</em></span>. Whenever a timer completes, the custom event will be triggered. Since we only need one timer per element, the <code class="literal">setup</code>
<a id="id875" class="indexterm"/> callback will serve our needs. By supplying a custom namespace for the <code class="literal">scroll</code> <a id="id876" class="indexterm"/>handler, we can easily <a id="id877" class="indexterm"/>remove the handler when <code class="literal">teardown</code> is called.</p><p>To use this new behavior, all we have to do is bind handlers to the <code class="literal">throttledScroll</code> event. This greatly simplifies the event binding code, and gives us a nicely reusable throttling mechanism, as follows:</p><div class="informalexample"><pre class="programlisting">(function($) {
  $.event.special.throttledScroll = {
    setup: function(data) {
      var timer = 0;
      $(this).on('scroll.throttledScroll', function(event) {
        if (!timer) {
          timer = setTimeout(function() {
            $(this).triggerHandler('throttledScroll');
            timer = 0;
          }, 250);
        }
      });
    },
    teardown: function() {
      $(this).off('scroll.throttledScroll');
    }
  };

  $(document).on('mouseenter mouseleave', 'div.photo', function(event) {
    var $details = $(this).find('.details');
    if (event.type == 'mouseenter') {
      $details.fadeTo('fast', 0.7);
    } else {
      $details.fadeOut('fast');
    }
  });

  $(document).on('nextPage', function(event, scrollToVisible) {
    var url = $('#more-photos').attr('href');
    if (url) {
      $.get(url, function(data) {
        var $data = $(data).appendTo('#gallery');
        if (scrollToVisible) {
          var newTop = $data.offset().top;
          $(window).scrollTop(newTop);
        }
        checkScrollPosition();
      });
    }
  });

  var pageNum = 1;
  $(document).on('nextPage', function() {
    pageNum++;
    if (pageNum &lt; 20) {
      $('#more-photos').attr('href', 'pages/' + pageNum + '.html');
    }
    else {
      $('#more-photos').remove();
    }
  });

  function checkScrollPosition() {
    var distance = $(window).scrollTop() + $(window).height();
    if ($('#container').height() &lt;= distance) {
      $(document).trigger('nextPage');
    }
  }

  $(document).ready(function() {
    $('#more-photos').click(function(event) {
      event.preventDefault();
      $(this).trigger('nextPage', [true]);
    });

<span class="strong"><strong>    $(window)</strong></span>
<span class="strong"><strong>      .on('throttledScroll', checkScrollPosition)</strong></span>
<span class="strong"><strong>      .trigger('throttledScroll');</strong></span>
  });
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 10.17</em></span>
</p><div class="section" title="More about special events"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec124"/>More about special events</h2></div></div></div><p>While this chapter covers advanced <a id="id878" class="indexterm"/>techniques for dealing with events, the event extension API is very advanced indeed, and a detailed investigation is beyond the scope of this book. The previous <code class="literal">throttledScroll</code> example covers the simplest and most common usage of the facility. Other possible applications include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Modifying the event object, so that event handlers have different information available to them</li><li class="listitem" style="list-style-type: disc">Causing events that occur in one place in the DOM to trigger behaviors associated with different elements</li><li class="listitem" style="list-style-type: disc">Reacting to new and browser-specific events that are not standard DOM events, and allowing jQuery code to react to them as if they are standard</li><li class="listitem" style="list-style-type: disc">Changing the way event bubbling and delegation are handled</li></ul></div><p>Many of these tasks can be quite complicated. For an in-depth take on the possibilities offered by the event extension API, <a id="id879" class="indexterm"/>we can investigate the jQuery Learning Center's documentation at <a class="ulink" href="http://learn.jquery.com/events/event-extensions/">http://learn.jquery.com/events/event-extensions/</a>.</p></div></div></body></html>
