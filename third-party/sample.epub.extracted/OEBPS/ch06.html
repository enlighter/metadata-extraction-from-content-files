<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter&#xA0;6.&#xA0;Sending Data with Ajax</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="chapter" title="Chapter&#xA0;6.&#xA0;Sending Data with Ajax"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter&#xA0;6.&#xA0;Sending Data with Ajax</h1></div></div></div><p>The term <span class="strong"><strong>Asynchronous JavaScript and XML</strong></span> (<span class="strong"><strong>Ajax</strong></span>) was coined by Jesse James Garrett in 2005. Since then it has come to <a id="id449" class="indexterm"/>represent many different things, as the term encompasses a group of related capabilities and techniques. At its most basic level, an Ajax solution includes the following technologies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JavaScript</strong></span>: This is used to <a id="id450" class="indexterm"/>capture interactions with the user or other browser-related events and to interpret the data from the server and present it on the page</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>XMLHttpRequest</strong></span>: This allows <a id="id451" class="indexterm"/>requests to be made to the server without interrupting other browser tasks</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Textual data:</strong></span> The server provides data in a format such as XML, HTML, or JSON</li></ul></div><p>Ajax has been hailed as the savior of the web landscape, transforming static web pages into interactive web applications. Unsurprisingly, browsers are not entirely consistent with regard to their implementations of the <code class="literal">XMLHttpRequest</code> object, but jQuery will assist us in taming this feature.</p><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading data from the server without a page refresh</li><li class="listitem" style="list-style-type: disc">Sending data from JavaScript in the browser back to the server</li><li class="listitem" style="list-style-type: disc">Interpreting data in a variety of formats, including HTML, XML, and JSON</li><li class="listitem" style="list-style-type: disc">Providing feedback to the user about the status of an Ajax request</li></ul></div><div class="section" title="Loading data on demand"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Loading data on demand</h1></div></div></div><p>Underneath all the hype and <a id="id452" class="indexterm"/>trappings, Ajax is just a means of loading data from the server to the web browser or client without a visible page refresh. This data can take many forms, and we have many options for what to do with it when it arrives. We'll see this by performing the same basic task in many ways.</p><p>We are going to build a page that displays entries from a dictionary, grouped by the starting letter of the dictionary <a id="id453" class="indexterm"/>entry. The HTML defining the content area of the page will look like this:</p><div class="informalexample"><pre class="programlisting">&lt;div id="dictionary"&gt;
&lt;/div&gt;</pre></div><p>Yes, really! Our page will have no content to begin with. We are going to use jQuery's various Ajax methods to populate this <code class="literal">&lt;div&gt;</code> tag with dictionary entries.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>
<span class="strong"><strong>Downloadable code examples</strong></span>
</p><p>As with many of the HTML, CSS, and JavaScript examples in this book, the previous markup is merely a fragment of the complete document. To experiment with the examples, we can download them from the Packt Publishing website at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>. In addition, the examples can be viewed in an interactive browser at <a class="ulink" href="http://book.learningjquery.com/">http://book.learningjquery.com/</a>.</p></div></div><p>We're going to need a way to trigger the loading process, so we'll add some links for our event handlers to latch onto:</p><div class="informalexample"><pre class="programlisting">&lt;div class="letters"&gt;
  &lt;div class="letter" id="letter-a"&gt;
    &lt;h3&gt;&lt;a href="entries-a.html"&gt;A&lt;/a&gt;&lt;/h3&gt;
  &lt;/div&gt;
  &lt;div class="letter" id="letter-b"&gt;
    &lt;h3&gt;&lt;a href="entries-a.html"&gt;B&lt;/a&gt;&lt;/h3&gt;
  &lt;/div&gt;
  &lt;div class="letter" id="letter-c"&gt;
    &lt;h3&gt;&lt;a href="entries-a.html"&gt;C&lt;/a&gt;&lt;/h3&gt;
  &lt;/div&gt;
  &lt;div class="letter" id="letter-d"&gt;
    &lt;h3&gt;&lt;a href="entries-a.html"&gt;D&lt;/a&gt;&lt;/h3&gt;
  &lt;/div&gt;
  &lt;!-- and so on --&gt;
&lt;/div&gt;</pre></div><p>These simple links will lead us to pages that list the dictionary entries for that letter. We will use progressive enhancement to allow these links to instead manipulate the page without a full page load.</p><p>With basic styling applied, this HTML will produce a page that looks like this:</p><div class="mediaobject"><img src="graphics/3145OS_06_01.jpg" alt="Loading data on demand"/></div><p>Now we can focus on getting <a id="id454" class="indexterm"/>content onto the page.</p><div class="section" title="Appending HTML"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Appending HTML</h2></div></div></div><p>Ajax applications are often no more <a id="id455" class="indexterm"/>than a request for a chunk of HTML. This technique, sometimes referred to as <a id="id456" class="indexterm"/>
<span class="strong"><strong>Asynchronous HTTP and HTML</strong></span> (<span class="strong"><strong>AHAH</strong></span>), is almost trivial to implement with jQuery. First, we need some HTML to insert, which we'll place in a file called <code class="literal">a.html</code> alongside <a id="id457" class="indexterm"/>our main document. This secondary HTML file begins as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div class="entry"&gt;
  &lt;h3 class="term"&gt;ABDICATION&lt;/h3&gt;
  &lt;div class="part"&gt;n.&lt;/div&gt;
  &lt;div class="definition"&gt;
    An act whereby a sovereign attests his sense of the high
    temperature of the throne.
    &lt;div class="quote"&gt;
      &lt;div class="quote-line"&gt;Poor Isabella's Dead, whose
      abdication&lt;/div&gt;
      &lt;div class="quote-line"&gt;Set all tongues wagging in the
      Spanish nation.&lt;/div&gt;
      &lt;div class="quote-line"&gt;For that performance 'twere
      unfair to scold her:&lt;/div&gt;
      &lt;div class="quote-line"&gt;She wisely left a throne too
      hot to hold her.&lt;/div&gt;
      &lt;div class="quote-line"&gt;To History she'll be no royal
      riddle &#x2014;&lt;/div&gt;
      &lt;div class="quote-line"&gt;Merely a plain parched pea that
      jumped the griddle.&lt;/div&gt;
      &lt;div class="quote-author"&gt;G.J.&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class="entry"&gt;
  &lt;h3 class="term"&gt;ABSOLUTE&lt;/h3&gt;
  &lt;div class="part"&gt;adj.&lt;/div&gt;
  &lt;div class="definition"&gt;
    Independent, irresponsible.  An absolute monarchy is one
    in which the sovereign does as he pleases so long as he
    pleases the assassins.  Not many absolute monarchies are
    left, most of them having been replaced by limited
    monarchies, where the sovereign's power for evil (and for
    good) is greatly curtailed, and by republics, which are
    governed by chance.
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>The page continues with more <a id="id458" class="indexterm"/>entries in this HTML structure. Rendered on its own, <code class="literal">a.html</code> is quite plain:</p><div class="mediaobject"><img src="graphics/3145OS_06_02.jpg" alt="Appending HTML"/></div><p>Note that <code class="literal">a.html</code> is not a true HTML document; it contains no <code class="literal">&lt;html&gt;</code>, <code class="literal">&lt;head&gt;</code>, or <code class="literal">&lt;body&gt;</code>, all of which are normally required. We <a id="id459" class="indexterm"/>usually call such a file a <span class="emphasis"><em>partial</em></span> or <span class="emphasis"><em>fragment</em></span>; its only purpose is to be inserted into another HTML document, which we'll accomplish now:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-a a').click(function(event) {
    event.preventDefault();
    $('#dictionary').load('a.html');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.1</em></span>
</p><p>The <code class="literal">.load()</code> method does all the <a id="id460" class="indexterm"/>heavy lifting for us. We specify the target location for the HTML snippet by using a normal jQuery selector, and then pass the URL of the file to be loaded as a parameter to the method. Now, when the first link is clicked, the file is loaded and placed inside <code class="literal">&lt;div id="dictionary"&gt;</code>. The browser will render the new HTML as soon as it is inserted.</p><div class="mediaobject"><img src="graphics/3145OS_06_03.jpg" alt="Appending HTML"/></div><p>Note that the HTML is now styled, whereas before it was plain. This is due to the CSS rules in the main document; as soon as the new HTML snippet is inserted, the rules apply to its elements as well.</p><p>When testing this example, the dictionary definitions will probably appear instantaneously when the button is clicked. This is a hazard of working on our applications locally; it is hard to account for delays or interruptions in transferring documents across the network. Suppose we added an alert box to display after the definitions are loaded:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-a a').click(function(event) {
    event.preventDefault();
    $('#dictionary').load('a.html');
    alert('Loaded!');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.2</em></span>
</p><p>We might assume from the structure of this code that the alert can only be displayed after the load has been performed. JavaScript execution is usually <span class="emphasis"><em>synchronous</em></span>, working on one task after another in strict sequence.</p><p>However, when this particular code is tested on a production web server, the alert will quite possibly have come and gone before the load has completed, due to network lag. This happens because all Ajax calls are by default <span class="emphasis"><em>asynchronous</em></span>. Otherwise, we'd have to call it "Sjax", which hardly has the <a id="id461" class="indexterm"/>same ring to it. Asynchronous loading means that once the HTTP request to retrieve the HTML snippet is issued, script execution immediately resumes without waiting. Some time later, the browser receives the response from the server and handles it. This is <a id="id462" class="indexterm"/>generally the desired behavior; it is unfriendly to lock up the whole web browser while waiting for data to be retrieved.</p><p>If actions must be delayed until the load has been completed, jQuery provides a callback for this. We've already seen callbacks in <a class="link" href="ch04.html" title="Chapter&#xA0;4.&#xA0;Styling and Animating">Chapter 4</a>, <span class="emphasis"><em>Styling and Animating</em></span>, using them to execute actions after an effect has completed. Ajax callbacks perform a similar function, executing after data arrives from the server. We will use this capability in our next example, as we learn how to read JSON data from the server.</p></div><div class="section" title="Working with JavaScript objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec65"/>Working with JavaScript objects</h2></div></div></div><p>Pulling in fully formed HTML on demand is very convenient, but it means having to transfer a lot of information about the <a id="id463" class="indexterm"/>HTML structure along with the actual content. There are times when we would rather transfer as little data as possible and process it after it arrives. In this case, we need to retrieve the data in a structure that we can traverse with JavaScript.</p><p>With jQuery's selectors, we could traverse the HTML we get back and manipulate it, but a more native JavaScript data format typically involves less data to transfer and less code to process it.</p><div class="section" title="Retrieving JSON"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec11"/>Retrieving JSON</h3></div></div></div><p>As we have often seen, JavaScript <a id="id464" class="indexterm"/>objects are just sets of key-value pairs, <a id="id465" class="indexterm"/>and can be defined succinctly using curly braces (<code class="literal">{}</code>). JavaScript arrays, on the other hand, are defined on the fly with square brackets (<code class="literal">[]</code>) and have implicit keys, which are incrementing integers. Combining these two concepts, we can easily express some very complex and rich data structures.</p><p>The term <span class="strong"><strong>JavaScript Object Notation</strong></span> (<span class="strong"><strong>JSON</strong></span>) was coined by Douglas Crockford to capitalize on this simple syntax. This <a id="id466" class="indexterm"/>
<a id="id467" class="indexterm"/>notation can offer a concise alternative to the bulky XML format:</p><div class="informalexample"><pre class="programlisting">{
  "key": "value",
  "key 2": [
    "array",
    "of",
    "items"
  ]
}</pre></div><p>While based on JavaScript object literals and array literals, JSON is more prescriptive about its syntax requirements and more restrictive about the values it allows. For example, JSON specifies that all object keys, as well as all string values must be enclosed in double quotes. Also, functions are not valid JSON values. Because of its strictness, developers should avoid hand-editing JSON and instead rely on software such as a server-side script to format it properly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>For information on JSON's syntax requirements, some of its potential advantages and its implementations in many programming languages, visit <a class="ulink" href="http://json.org/.http://json.org/">http://json.org/.http://json.org/</a>.</p></div></div><p>We can encode our data using this format in many ways. To illustrate one approach, we'll place some dictionary entries in a JSON file that we'll call <code class="literal">b.json</code>:</p><div class="informalexample"><pre class="programlisting">[
  {
    "term": "BACCHUS",
    "part": "n.",
    "definition": "A convenient deity invented by the...",
    "quote": [
      "Is public worship, then, a sin,",
      "That for devotions paid to Bacchus",
      "The lictors dare to run us in,",
      "And resolutely thump and whack us?"
    ],
    "author": "Jorace"
  },
  {
    "term": "BACKBITE",
    "part": "v.t.",
    "definition": "To speak of a man as you find him when..."
  },
  {
    "term": "BEARD",
    "part": "n.",
    "definition": "The hair that is commonly cut off by..."
  },
  ... file continues ...</pre></div><p>To retrieve this data, we'll use the <a id="id468" class="indexterm"/>
<code class="literal">$.getJSON()</code> method, which fetches the file and processes it. When the data arrives from the server, it is simply a text string in JSON format. The <code class="literal">$.getJSON()</code> method <a id="id469" class="indexterm"/>parses this string and provides the calling <a id="id470" class="indexterm"/>code with the resulting JavaScript object.</p></div><div class="section" title="Using global jQuery functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec12"/>Using global jQuery functions</h3></div></div></div><p>To this point, all <a id="id471" class="indexterm"/>
<a id="id472" class="indexterm"/>jQuery methods that we've used have been attached to a jQuery object that we've built with the <code class="literal">$()</code> function. The selectors have allowed us to specify a set of DOM nodes to work with, and the methods have operated on them in some way. This <code class="literal">$.getJSON()</code> function, however, is different. There is no logical DOM element to which it could apply; the resulting object has to be provided to the script, not injected into the page. For this reason, <code class="literal">getJSON()</code> is defined as a method of the global jQuery object (a single object called <code class="literal">jQuery</code> or <code class="literal">$</code> defined once by the jQuery library), rather than of an individual jQuery object instance (the object returned by the <code class="literal">$()</code> function).</p><p>If JavaScript had classes like other object-oriented languages, we'd call <code class="literal">$.getJSON()</code> a class method. For our purposes, we'll refer to this type of method as a global function; in effect, they are functions that use the <code class="literal">jQuery</code> namespace so as not to conflict with other function names.</p><p>To use this function, we pass it the filename as before:</p><div class="informalexample"><pre class="programlisting">// Unfinished code
$(document).ready(function() {
  $('#letter-b a').click(function(event) {
    event.preventDefault();
    $.getJSON('b.json');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.3</em></span>
</p><p>This code has no apparent effect when we click on the link. The function call loads the file, but we have not told JavaScript what to do with the resulting data. For this, we need to use a callback function.</p><p>The <code class="literal">$.getJSON()</code> function <a id="id473" class="indexterm"/>takes a second argument, which is a function to be called when the load is complete. As mentioned earlier, Ajax calls are asynchronous, and the callback provides a way to wait for the data to be transmitted rather than executing code right away. The callback function also takes an argument, which is filled with the resulting data. So, we can write:</p><div class="informalexample"><pre class="programlisting">// Unfinished code
$(document).ready(function() {
  $('#letter-b a').click(function(event) {
    event.preventDefault();
    $.getJSON('b.json', function(data) {
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.4</em></span>
</p><p>Here we are using an anonymous function expression as our callback, as we have done in the past to keep our jQuery <a id="id474" class="indexterm"/>
<a id="id475" class="indexterm"/>code concise. A reference to a function declaration could equally be provided as the callback.</p><p>Inside this function, we can use the <code class="literal">data</code> variable to traverse the JSON structure as necessary. We'll need to iterate over the top-level array, building the HTML for each item. We could do this with a standard <code class="literal">for</code> loop, but instead we'll introduce another of jQuery's useful global functions, <code class="literal">$.each()</code>. We saw its counterpart, the <code class="literal">.each()</code> method, in <a class="link" href="ch05.html" title="Chapter&#xA0;5.&#xA0;Manipulating the DOM">Chapter 5</a>, <span class="emphasis"><em>Manipulating the DOM</em></span>. Instead of operating on a jQuery collection of DOM elements, this function takes an array or object as its first parameter and a callback function as its second. Each time through the loop, the current iteration index and the current item in the array or object are passed as two parameters to the callback function.</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-b a').click(function(event) {
    event.preventDefault();
    $.getJSON('b.json', function(data) {
      var html = '';
      $.each(data, function(entryIndex, entry) {
        html += '&lt;div class="entry"&gt;';
        html += '&lt;h3 class="term"&gt;' + entry.term + '&lt;/h3&gt;';
        html += '&lt;div class="part"&gt;' + entry.part + '&lt;/div&gt;';
        html += '&lt;div class="definition"&gt;';
        html += entry.definition;
        html += '&lt;/div&gt;';
        html += '&lt;/div&gt;';
      });
      $('#dictionary').html(html);
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.5</em></span>
</p><p>We use <code class="literal">$.each()</code> to examine each item in turn, building an HTML structure using the contents of the entry object. Once all the HTML has been built for each entry, we insert it into <code class="literal">&lt;div id="dictionary"&gt;</code> with <code class="literal">.html()</code>, replacing anything that may have already been there.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>
<span class="strong"><strong>Safe HTML</strong></span>
</p><p>This approach presumes that the data is safe for HTML consumption; it should not contain any stray <code class="literal">&lt;</code> characters, for example.</p></div></div><p>All that's left is to handle the entries with quotations, which takes another <code class="literal">$.each()</code> loop:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-b a').click(function(event) {
    event.preventDefault();
    $.getJSON('b.json', function(data) {
      var html = '';
      $.each(data, function(entryIndex, entry) {
        html += '&lt;div class="entry"&gt;';
        html += '&lt;h3 class="term"&gt;' + entry.term + '&lt;/h3&gt;';
        html += '&lt;div class="part"&gt;' + entry.part + '&lt;/div&gt;';
        html += '&lt;div class="definition"&gt;';
        html += entry.definition;
<span class="strong"><strong>        if (entry.quote) {</strong></span>
<span class="strong"><strong>          html += '&lt;div class="quote"&gt;';</strong></span>
<span class="strong"><strong>          $.each(entry.quote, function(lineIndex, line) {</strong></span>
<span class="strong"><strong>            html += '&lt;div class="quote-line"&gt;' + line + '&lt;/div&gt;';</strong></span>
<span class="strong"><strong>          });</strong></span>
<span class="strong"><strong>          if (entry.author) {</strong></span>
<span class="strong"><strong>            html += '&lt;div class="quote-author"&gt;' + entry.author + '&lt;/div&gt;';</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>          html += '&lt;/div&gt;';</strong></span>
<span class="strong"><strong>        }</strong></span>
        html += '&lt;/div&gt;';
        html += '&lt;/div&gt;';
      });
      $('#dictionary').html(html);
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.6</em></span>
</p><p>With this code in place, we can click on the <span class="strong"><strong>B</strong></span> link and confirm our results. The dictionary entries are displayed on the right-hand side of the page, as expected:</p><div class="mediaobject"><img src="graphics/3145OS_06_04.jpg" alt="Using global jQuery functions"/></div><p>The JSON format is concise, but not forgiving. Every bracket, brace, quote, and comma must be present and accounted for, or the file will not load. In some cases, we won't even get an error message; the script will just silently fail.</p></div><div class="section" title="Executing a script"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec13"/>Executing a script</h3></div></div></div><p>Occasionally, we don't want to <a id="id476" class="indexterm"/>retrieve all the JavaScript we will need when the page is first loaded. We might not know what scripts will be necessary until some user interaction occurs. We could introduce the <code class="literal">&lt;script&gt;</code> tags on the fly when they are needed, but a more elegant way to inject additional code is to have jQuery load the <code class="literal">.js</code> file directly.</p><p>Pulling in a script is about as simple as loading an HTML fragment. In this case, we use the <code class="literal">$.getScript()</code> function, which&#x2014;like its siblings&#x2014;accepts a URL locating the script file:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-c a').click(function(event) {
    event.preventDefault();
    $.getScript('c.js');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.7</em></span>
</p><p>In our last example, we needed to process the result data so that we could do something useful with the loaded file. With a script file, though, the processing is automatic; the script is simply run.</p><p>Scripts fetched in this way are run in the global context of the current page. This means they have access to all globally defined functions and variables, notably including jQuery itself. We can, therefore, mimic the JSON example to prepare and insert HTML on the page when the script is <a id="id477" class="indexterm"/>executed, and place this code in <code class="literal">c.js</code>:</p><div class="informalexample"><pre class="programlisting">var entries = [
  {
    "term": "CALAMITY",
    "part": "n.",
    "definition": "A more than commonly plain and..."
  },
  {
    "term": "CANNIBAL",
    "part": "n.",
    "definition": "A gastronome of the old school who..."
  },
  {
    "term": "CHILDHOOD",
    "part": "n.",
    "definition": "The period of human life intermediate..."
  }
  // and so on
];

var html = '';

$.each(entries, function() {
  html += '&lt;div class="entry"&gt;';
  html += '&lt;h3 class="term"&gt;' + this.term + '&lt;/h3&gt;';
  html += '&lt;div class="part"&gt;' + this.part + '&lt;/div&gt;';
  html += '&lt;div class="definition"&gt;' + this.definition + '&lt;/div&gt;';
  html += '&lt;/div&gt;';
});

$('#dictionary').html(html);</pre></div><p>Now, clicking on the <span class="strong"><strong>C</strong></span> link has the expected result, showing the appropriate dictionary entries.</p></div></div><div class="section" title="Loading an XML document"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Loading an XML document</h2></div></div></div><p>XML is part of the acronym Ajax, <a id="id478" class="indexterm"/>but we haven't actually loaded any XML yet. Doing so is straightforward, and mirrors the JSON technique fairly closely. First, we'll need an XML file, <code class="literal">d.xml</code>, containing some data we wish to display:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;entries&gt;
  &lt;entry term="DEFAME" part="v.t."&gt;
    &lt;definition&gt;
      To lie about another.  To tell the truth about another.
    &lt;/definition&gt;
  &lt;/entry&gt;
  &lt;entry term="DEFENCELESS" part="adj."&gt;
    &lt;definition&gt;
      Unable to attack.
    &lt;/definition&gt;
  &lt;/entry&gt;
  &lt;entry term="DELUSION" part="n."&gt;
    &lt;definition&gt;
      The father of a most respectable family, comprising
      Enthusiasm, Affection, Self-denial, Faith, Hope,
      Charity and many other goodly sons and daughters.
    &lt;/definition&gt;
    &lt;quote author="Mumfrey Mappel"&gt;
      &lt;line&gt;All hail, Delusion!  Were it not for thee&lt;/line&gt;
      &lt;line&gt;The world turned topsy-turvy we should see;
        &lt;/line&gt;
      &lt;line&gt;For Vice, respectable with cleanly fancies,
        &lt;/line&gt;
      &lt;line&gt;Would fly abandoned Virtue's gross advances.
        &lt;/line&gt;
    &lt;/quote&gt;
  &lt;/entry&gt;
&lt;/entries&gt;</pre></div><p>This data could be expressed in many ways, of course, and some would more closely mimic the structure we established for the HTML or JSON used earlier. Here, however, we're illustrating some of the features of XML designed to make it more readable to humans, such as the use of attributes for <code class="literal">term</code> and <code class="literal">part</code> rather than tags.</p><p>We'll start off our function in a familiar manner:</p><div class="informalexample"><pre class="programlisting">// Unfinished code
$(document).ready(function() {
  $('#letter-d a').click(function(event) {
    event.preventDefault();
    $.get('d.xml', function(data) {

    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.8</em></span>
</p><p>This time, it's the <a id="id479" class="indexterm"/>
<code class="literal">$.get()</code> function that does our work. In general, this function simply fetches the file at the supplied URL and provides the plain text to the callback. However, if the response is known to be XML because of its server-supplied MIME type, the callback will be handed the XML DOM tree.</p><p>Fortunately, as we have already seen,<a id="id480" class="indexterm"/> jQuery has substantial DOM-traversing capabilities. We can use the normal <code class="literal">.find()</code>, <code class="literal">.filter()</code>, and other traversal methods on the XML document just as we would on HTML:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-d a').click(function(event) {
    event.preventDefault();
    $.get('d.xml', function(data) {
      $('#dictionary').empty();
      $(data).find('entry').each(function() {
        var $entry = $(this);
        var html = '&lt;div class="entry"&gt;';
        html += '&lt;h3 class="term"&gt;' + $entry.attr('term');
          html += '&lt;/h3&gt;';
        html += '&lt;div class="part"&gt;' + $entry.attr('part');
          html += '&lt;/div&gt;';
        html += '&lt;div class="definition"&gt;';
        html += $entry.find('definition').text();
        var $quote = $entry.find('quote');
        if ($quote.length) {
          html += '&lt;div class="quote"&gt;';
          $quote.find('line').each(function() {
            html += '&lt;div class="quote-line"&gt;';
              html += $(this).text() + '&lt;/div&gt;';
          });
          if ($quote.attr('author')) {
            html += '&lt;div class="quote-author"&gt;';
              html += $quote.attr('author') + '&lt;/div&gt;';
          }
          html += '&lt;/div&gt;';
        }
        html += '&lt;/div&gt;';
        html += '&lt;/div&gt;';
        $('#dictionary').append($(html));
      });
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.9</em></span>
</p><p>This has the expected effect when the <span class="strong"><strong>D</strong></span> link is clicked:</p><div class="mediaobject"><img src="graphics/3145OS_06_05.jpg" alt="Loading an XML document"/></div><p>This is a new use for the DOM traversal methods we already know, shedding some light on the flexibility of jQuery's CSS <a id="id481" class="indexterm"/>selector support. CSS syntax is typically used to help beautify HTML pages, and thus selectors in standard <code class="literal">.css</code> files use HTML tag names such as <code class="literal">div</code> and <code class="literal">body</code> to locate content. However, jQuery can use arbitrary XML tag names, such as <code class="literal">entry</code> and <code class="literal">definition</code>, just as readily as the standard HTML ones.</p><p>The advanced selector engine inside jQuery facilitates finding parts of the XML document in much more complicated situations as well. For example, suppose we wanted to limit the displayed entries to those that have quotes that in turn have attributed authors. To do this, we can limit the entries to those with the nested <code class="literal">&lt;quote&gt;</code> elements by changing <code class="literal">entry</code> to <code class="literal">entry:has(quote)</code>. Then, we can further restrict the entries to those with <code class="literal">author</code> attributes on the <code class="literal">&lt;quote&gt;</code> elements by writing <code class="literal">entry:has(quote[author])</code>. The line in <span class="emphasis"><em>Listing 6.9</em></span> with the initial selector now reads:</p><div class="informalexample"><pre class="programlisting">$(data).find('entry:has(quote[author])').each(function() {</pre></div><p>This new selector expression restricts the returned entries correspondingly:</p><div class="mediaobject"><img src="graphics/3145OS_06_06.jpg" alt="Loading an XML document"/></div></div></div></div></body></html>
