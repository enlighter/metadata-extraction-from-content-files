<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Handling memory-leak hazards</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Handling memory-leak hazards"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec110"/>Handling memory-leak hazards</h1></div></div></div><p>JavaScript manages its memory using a technique known as garbage collection. This is in contrast to low-level languages <a id="id1151" class="indexterm"/>such as C, which require programmers to explicitly reserve blocks of memory and free them when they are no longer being used. Other languages such as Objective-C assist the programmer by implementing a reference-counting system, which allows the user to note how many pieces of the program are using a particular piece of memory so it can be cleaned up when no longer used. JavaScript is a high-level language, on the other hand, and generally takes care of this bookkeeping behind the scenes.</p><p>Whenever a new memory-resident item such as an object or function comes into being in JavaScript code, a chunk of memory is set aside for this item. As the object gets passed around to functions and assigned to variables, more pieces of code begin to point to the object. JavaScript keeps track of these pointers, and when the last one is gone, the memory taken by the object is released. Consider a chain of pointers:</p><div class="mediaobject"><img src="graphics/3145OS_AppA_01.jpg" alt="Handling memory-leak hazards"/></div><p>Here, object <span class="emphasis"><em>A</em></span> has a property that points to <span class="emphasis"><em>B</em></span> and <span class="emphasis"><em>B</em></span> has a property that points to <span class="emphasis"><em>C</em></span>. Even if object <span class="emphasis"><em>A</em></span> here is the only one that is a variable in the current scope, all three objects must remain in memory because of the pointers to them. When <span class="emphasis"><em>A</em></span> goes out of scope, however (such as at the end of the function it was declared in), then it can be released by the garbage collector. Now <span class="emphasis"><em>B</em></span> has nothing pointing to it, so it can be released, and finally <span class="emphasis"><em>C</em></span> can be released as well.</p><p>More complicated arrangements of references can be harder to deal with:</p><div class="mediaobject"><img src="graphics/3145OS_AppA_02.jpg" alt="Handling memory-leak hazards"/></div><p>Now we've added a property to object <span class="emphasis"><em>C</em></span> that refers back to <span class="emphasis"><em>B</em></span>. In this case, when <span class="emphasis"><em>A</em></span> is released, <span class="emphasis"><em>B</em></span> still has a pointer to it from <span class="emphasis"><em>C</em></span>. This reference loop needs to be handled specially by JavaScript, which <a id="id1152" class="indexterm"/>must notice that the entire loop is isolated from the variables that are in scope.</p><div class="section" title="Avoiding accidental reference loops"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec158"/>Avoiding accidental reference loops</h2></div></div></div><p>Closures can cause reference <a id="id1153" class="indexterm"/>loops to be inadvertently created. Since functions are objects that must be kept in memory, any variables they have in their closing environment are also kept in memory. Consider the following code:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
  var outerVar = {};
  function innerFn() {
    console.log(outerVar);
  }
  outerVar.fn = innerFn;
  return innerFn;
};</pre></div><p>
<span class="emphasis"><em>Listing A.20</em></span>
</p><p>Here, an object called <code class="literal">outerVar</code> is created and referenced from within the inner function <code class="literal">innerFn()</code>. Then, a property of <code class="literal">outerVar</code> that points to <code class="literal">innerFn()</code> is created and <code class="literal">innerFn()</code> is returned. This creates a closure on <code class="literal">innerFn()</code> that refers to <code class="literal">outerVar</code>, which in turn refers back to <code class="literal">innerFn()</code>.</p><p>Scenarios such as this can keep variables in memory longer than desired, but are fairly easy to notice. Sometimes, though, the loop can be even more insidious than this:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
  var outerVar = {};
  function innerFn() {
<span class="strong"><strong>    console.log('hello');</strong></span>
  }
  outerVar.fn = innerFn;
  return innerFn;
};</pre></div><p>
<span class="emphasis"><em>Listing A.21</em></span>
</p><p>Here, we've changed <code class="literal">innerFn()</code> so that it no longer refers to <code class="literal">outerVar</code>. However, this does not break the loop! Even though <code class="literal">outerVar</code> is never referred to from <code class="literal">innerFn()</code>, it is still in the closing <a id="id1154" class="indexterm"/>environment of <code class="literal">innerFn()</code>. All variables in the scope of <code class="literal">outerFn()</code> are implicitly referred to by <code class="literal">innerFn()</code> due to the closure. So, closures make it easy to accidentally create these loops.</p></div><div class="section" title="Managing loops between the DOM and JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec159"/>Managing loops between the DOM and JavaScript</h2></div></div></div><p>All of this is generally not <a id="id1155" class="indexterm"/>an issue because JavaScript is able to detect these <a id="id1156" class="indexterm"/>loops and clean them up when they become orphaned. Older versions of Internet Explorer, however, have difficulty handling one particular class of reference loops. When a loop contains both DOM elements and regular JavaScript objects, Internet Explorer cannot release either one because <a id="id1157" class="indexterm"/>they are handled by different memory <a id="id1158" class="indexterm"/>managers. These loops are never freed until the browser is closed, which can eat up a great deal of memory over time. A common cause of such a loop is a simple <code class="literal">event</code> handler:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var button = document.getElementById('button-1');
  button.onclick = function() {
    console.log('hello');
    return false;
  };
});</pre></div><p>
<span class="emphasis"><em>Listing A.22</em></span>
</p><p>When the <code class="literal">click</code> <a id="id1159" class="indexterm"/>handler is assigned, this creates a closure with <code class="literal">button</code> in the closing environment. But <code class="literal">button</code> now contains a reference back to the closure&#x2014;the <code class="literal">onclick</code> <a id="id1160" class="indexterm"/>property itself. Thus, the resulting loop can't be released by Internet Explorer even when we navigate away from the page.</p><p>To release the memory, we'd need to break the loop, such as by getting rid of the <code class="literal">onclick</code> property before the window is closed (taking care not to introduce a new loop between the window and its <a id="id1161" class="indexterm"/>
<code class="literal">onunload</code> hander). Alternatively, we could rewrite the code to avoid the closure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>function hello() {</strong></span>
  console.log('hello');
  return false;
}
$(document).ready(function() {
  var button = document.getElementById('button-1');
<span class="strong"><strong>  button.onclick = hello;</strong></span>
});</pre></div><p>
<span class="emphasis"><em>Listing A.23</em></span>
</p><p>Since the <code class="literal">hello()</code> function <a id="id1162" class="indexterm"/>no longer closes over <a id="id1163" class="indexterm"/>
<code class="literal">button</code>, the reference only goes one way (from <code class="literal">button</code> to <code class="literal">hello</code>) and <a id="id1164" class="indexterm"/>there is no loop, and <a id="id1165" class="indexterm"/>therefore no memory leak.</p><div class="section" title="Disentangling reference loops with jQuery"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec28"/>Disentangling reference loops with jQuery</h3></div></div></div><p>Now let's write the <a id="id1166" class="indexterm"/>same code, but using normal jQuery constructs:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var $button = $('#button-1');
  $button.click(function(event) {
    event.preventDefault();
    console.log('hello');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing A.24</em></span>
</p><p>Even though a closure is still created causing the same kind of loop as before, we do not get an IE memory leak from this code. Fortunately for us, jQuery is aware of the potential leaks and manually releases all the <code class="literal">event</code> handlers that it assigns. As long as we faithfully adhere to using jQuery's event-binding methods for our handlers, we need not fear leaks caused by this particular common idiom.</p><p>This doesn't mean we're completely out of the woods. We must continue to take care when we're performing other tasks with DOM elements. Attaching JavaScript objects to DOM elements can still cause memory leaks in older Internet Explorer versions; jQuery just helps make this situation far less prevalent.</p><p>Because of this, jQuery gives us another tool to help avoid these leaks. In <a class="link" href="ch12.html" title="Chapter&#xA0;12.&#xA0;Advanced DOM Manipulation">Chapter 12</a>, <span class="emphasis"><em>Advanced DOM Manipulation</em></span>, we <a id="id1167" class="indexterm"/>saw that the <code class="literal">.data()</code> method allows us to attach information to DOM elements in much the same way as we can with expando properties. Since this data is not stored directly as an expando (jQuery uses an internal map to store the data using IDs it creates), the reference loop is never formed and we sidestep the memory leak issue. Whenever an expando seems like a convenient data storage mechanism, we should consider <code class="literal">.data()</code> a safer alternative.</p></div></div></div></body></html>
