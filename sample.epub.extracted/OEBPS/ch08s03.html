<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Adding jQuery object methods</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Adding jQuery object methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Adding jQuery object methods</h1></div></div></div><p>Most of jQuery's built-in <a id="id649" class="indexterm"/>functionality is provided through its object instance methods, and this is where plugins shine as well. Whenever we would write a function that acts on part of the DOM, it is probably appropriate instead to create an instance method.</p><p>We have seen that adding global functions requires extending the <code class="literal">jQuery</code> object with new methods. Adding instance methods is similar, but we instead extend the <code class="literal">jQuery.fn</code> object:</p><div class="informalexample"><pre class="programlisting">jQuery.fn.myMethod = function() {
  alert('Nothing happens.');
};</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p>The <code class="literal">jQuery.fn</code> object is an alias to <code class="literal">jQuery.prototype</code>, provided for conciseness.</p></div></div><p>We can then call this new method from our code after using any selector expression:</p><div class="informalexample"><pre class="programlisting">$('div').myMethod();</pre></div><p>Our alert is displayed (once for each <code class="literal">&lt;div&gt;</code> in the document) when we invoke the method. We might as well have written a global function, though, as we haven't used the matched DOM nodes in any way. A reasonable method implementation acts on its context.</p><div class="section" title="Object method context"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec91"/>Object method context</h2></div></div></div><p>Within any plugin method, the <a id="id650" class="indexterm"/>keyword <code class="literal">this</code> is set to the current jQuery object. Therefore, we can call any built-in jQuery method on <code class="literal">this</code> or extract its DOM nodes and work on them. To examine what we can do with object context, we'll write a small plugin to manipulate the classes on the matched elements.</p><p>Our new method will take two class names and swap which class is applied to each element with every invocation. While jQuery <a id="id651" class="indexterm"/>UI has a robust <code class="literal">.switchClass()</code> method that even permits animating the class change, we'll provide a simple implementation for demonstration purposes:</p><div class="informalexample"><pre class="programlisting">// Unfinished code
(function($) {
  $.fn.swapClass = function(class1, class2) {
    if (this.hasClass(class1)) {
      this.removeClass(class1).addClass(class2);
    }
    else if (this.hasClass(class2)) {
      this.removeClass(class2).addClass(class1);
    }
  };
})(jQuery);

$(document).ready(function() {
  $('table').click(function() {
    $('tr').swapClass('one', 'two');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 8.8</em></span>
</p><p>In our plugin, we first test for the presence of <code class="literal">class1</code> on the matched element and substitute <code class="literal">class2</code> if it is found. Otherwise, we test for <code class="literal">class2</code> and switch in <code class="literal">class1</code> if necessary. If neither class is currently present, we do nothing.</p><p>In the code that uses the plugin, we bind a <code class="literal">click</code> handler to the table, calling <code class="literal">.swapClass()</code> on <a id="id652" class="indexterm"/>every row when the table is clicked. We'd expect this to change the class of the header row from <code class="literal">one</code> to <code class="literal">two</code> and to change the class of the sum row from <code class="literal">two</code> to <code class="literal">one</code>. </p><p>However, we observe a different result:</p><div class="mediaobject"><img src="graphics/3145_08_03.jpg" alt="Object method context"/></div><p>Every row has received the <code class="literal">two</code> <a id="id653" class="indexterm"/>class. To fix this, we need to correctly handle jQuery objects with multiple selected elements.</p></div><div class="section" title="Implicit iteration"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec92"/>Implicit iteration</h2></div></div></div><p>We need to remember that a <a id="id654" class="indexterm"/>jQuery selector expression can always match zero, one, or multiple elements. We must allow for any of these scenarios when designing a plugin method. In this case, we are calling <code class="literal">.hasClass()</code>, <a id="id655" class="indexterm"/>which only examines the first matched element. Instead, we need to check each element independently and act on it.</p><p>The easiest way to guarantee proper behavior regardless of the number of matched elements is to always call <code class="literal">.each()</code> on the method context; this enforces implicit iteration, which is important for maintaining consistency between plugin and built-in methods. Within the <code class="literal">.each()</code> call, <code class="literal">this</code> refers to each DOM element in turn so we can adjust our code to separately test for and apply classes to each matched element:</p><div class="informalexample"><pre class="programlisting">(function($) {
  $.fn.swapClass = function(class1, class2) {
<span class="strong"><strong>    this.each(function() {</strong></span>
      var $element = $(this);
      if ($element.hasClass(class1)) {
        $element.removeClass(class1).addClass(class2);
      }
      else if ($element.hasClass(class2)) {
        $element.removeClass(class2).addClass(class1);
      }
<span class="strong"><strong>    });</strong></span>
  };
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 8.9</em></span>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip46"/>Tip</h3><p>
<span class="strong"><strong>The meaning of "this"</strong></span>
</p><p>Caution: The keyword <a id="id656" class="indexterm"/>
<code class="literal">this</code> refers to a jQuery object within the object method's body, but refers to a DOM element within the <code class="literal">.each()</code> invocation.</p></div></div><p>Now when we click on the <a id="id657" class="indexterm"/>table, the classes are switched without affecting the rows that have neither class applied:</p><div class="mediaobject"><img src="graphics/3145_08_04.jpg" alt="Implicit iteration"/></div></div><div class="section" title="Enabling method chaining"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec93"/>Enabling method chaining</h2></div></div></div><p>In addition to implicit iteration, <a id="id658" class="indexterm"/>jQuery users should be able to rely on chaining behavior. This means that we need to return a jQuery object from all plugin methods, unless the method is clearly intended to retrieve a different piece of information. The returned jQuery object is usually just the one provided as <code class="literal">this</code>. If we use <code class="literal">.each()</code> to iterate over <code class="literal">this</code>, we can just return its result:</p><div class="informalexample"><pre class="programlisting">(function($) {
  $.fn.swapClass = function(class1, class2) {
<span class="strong"><strong>    return this.each(function() {</strong></span>
      var $element = $(this);
      if ($element.hasClass(class1)) {
        $element.removeClass(class1).addClass(class2);
      }
      else if ($element.hasClass(class2)) {
        $element.removeClass(class2).addClass(class1);
      }
    });
  };
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 8.10</em></span>
</p><p>Previously, when we called <code class="literal">.swapClass()</code>, we had to start a new statement to do anything else with the elements. <a id="id659" class="indexterm"/>With the <code class="literal">return</code> statement in place, though, we can freely chain our plugin method with built-in methods.</p></div></div></body></html>
