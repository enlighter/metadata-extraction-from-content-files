<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Passing data to the server</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Passing data to the server"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Passing data to the server</h1></div></div></div><p>Our examples to this point have <a id="id485" class="indexterm"/>focused on the task of retrieving static data files from the <a id="id486" class="indexterm"/>web server. However, the Ajax technique really comes into its own only when the server can dynamically shape the data based on input from the browser. We're helped along by jQuery in this task as well; all of the methods we've covered so far can be modified so that data transfer becomes a two-way street.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip35"/>Tip</h3><p>
<span class="strong"><strong>Interacting with server-side code</strong></span>
</p><p>Since demonstrating these techniques requires interaction with the web server, we'll need to use server-side code for the first time here. The examples given will use the PHP scripting language, which is very widely used as well as freely available. We will not cover how to set up a web server with PHP here; beginners should consider a package such as <a id="id487" class="indexterm"/>XAMPP, which can be found at <a class="ulink" href="http://www.apachefriends.org/en/xampp.html">http://www.apachefriends.org/en/xampp.html</a>, to get started quickly.</p></div></div><div class="section" title="Performing a GET request"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Performing a GET request</h2></div></div></div><p>To illustrate the communication <a id="id488" class="indexterm"/>between client (using JavaScript) and server (using <a id="id489" class="indexterm"/>PHP in our example), we'll write a script that only sends one dictionary entry to the browser on each request. The entry chosen will depend on a parameter sent from the browser. Our script will pull its data from an internal data structure like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php
$entries = array(
  'EAVESDROP' =&gt; array(
    'part' =&gt; 'v.i.',
    'definition' =&gt; 'Secretly to overhear a catalogue of the
      crimes and vices of another or yourself.',
    'quote' =&gt; array(
      'A lady with one of her ears applied',
      'To an open keyhole heard, inside,',
      'Two female gossips in converse free &#x2014;',
      'The subject engaging them was she.',
      '"I think," said one, "and my husband thinks',
      'That she\'s a prying, inquisitive minx!"',
      'As soon as no more of it she could hear',
      'The lady, indignant, removed her ear.',
      '"I will not stay," she said, with a pout,',
      '"To hear my character lied about!"',
    ),
    'author' =&gt; 'Gopete Sherany',
  ),
  'EDIBLE' =&gt; array(
    'part' =&gt; 'adj.',
    'definition' =&gt; 'Good to eat, and wholesome to digest, as
      a worm to a toad, a toad to a snake, a snake to a pig,
      a pig to a man, and a man to a worm.',
  ),
// and so on
);
?&gt;</pre></div><p>In a production version of this example, the data would probably be stored in a database and loaded on demand. Since the data is a part of the script here, the code to retrieve it is quite straightforward. We examine the data that has been posted and call a function that returns the HTML snippet to display:</p><div class="informalexample"><pre class="programlisting">&lt;?php
if (isset($entries[strtoupper($_REQUEST['term'])])) {
  $term = strtoupper($_REQUEST['term']);
  $entry = $entries[$term];
  echo build_entry($term, $entry);
} else {
  echo '&lt;div&gt;Sorry, your term was not found.&lt;/div&gt;';
}

function build_entry($term, $entry) {
  $html = '&lt;div class="entry"&gt;';
  $html .= '&lt;h3 class="term"&gt;';
  $html .= $term;
  $html .= '&lt;/h3&gt;';

  $html .= '&lt;div class="part"&gt;';
  $html .= $entry['part'];
  $html .= '&lt;/div&gt;';

  $html .= '&lt;div class="definition"&gt;';
  $html .= $entry['definition'];
  if (isset($entry['quote'])) {
    foreach ($entry['quote'] as $line) {
      $html .= '&lt;div class="quote-line"&gt;'. $line .'&lt;/div&gt;';
    }
    if (isset($entry['author'])) {
      $html .= '&lt;div class="quote-author"&gt;'.
        $entry['author'] .'&lt;/div&gt;';
    }
  }
  $html .= '&lt;/div&gt;';

  $html .= '&lt;/div&gt;';
  return $html;
}
?&gt;</pre></div><p>Now, requests to this script, which <a id="id490" class="indexterm"/>we'll call <code class="literal">e.php</code>, will return the HTML snippet <a id="id491" class="indexterm"/>corresponding to the term that was sent in the GET parameters. For example, when accessing the script with <code class="literal">e.php?term=eavesdrop</code>, we get back:</p><div class="mediaobject"><img src="graphics/3145OS_06_07.jpg" alt="Performing a GET request"/></div><p>Once again, we note the lack of formatting we saw with earlier HTML snippets, because CSS rules have not been applied.</p><p>Since we're showing how data is <a id="id492" class="indexterm"/>passed to the server, we will use a different method to request entries than the solitary buttons we've been relying on so far. Instead, we'll <a id="id493" class="indexterm"/>present a list of links for each term, and cause a click on any of them to load the corresponding definition. The HTML we'll add for this looks like the following:</p><div class="informalexample"><pre class="programlisting">&lt;div class="letter" id="letter-e"&gt;
  &lt;h3&gt;E&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href="e.php?term=Eavesdrop"&gt;Eavesdrop&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Edible"&gt;Edible&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Education"&gt;Education&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Eloquence"&gt;Eloquence&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Elysium"&gt;Elysium&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Emancipation"&gt;Emancipation&lt;/a&gt;
      &lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Emotion"&gt;Emotion&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Envelope"&gt;Envelope&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Envy"&gt;Envy&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Epitaph"&gt;Epitaph&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="e.php?term=Evangelist"&gt;Evangelist&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre></div><p>Now we need to get our JavaScript code to call the PHP script with the right parameters. We could do this with the normal <code class="literal">.load()</code> mechanism, appending the query string right to the URL and fetching data with addresses such as <code class="literal">e.php?term=eavesdrop</code> directly. Instead, though, we can have jQuery <a id="id494" class="indexterm"/>construct the query string based on an object we provide to the <code class="literal">$.get()</code> function.</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-e a').click(function(event) {
    event.preventDefault();
    var requestData = {term: $(this).text()};
    $.get('e.php', requestData, function(data) {
      $('#dictionary').html(data);
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.10</em></span>
</p><p>Now that we have seen other Ajax interfaces that jQuery provides, the operation of this function seems familiar. The only <a id="id495" class="indexterm"/>difference is the second parameter, which allows us to supply an object containing keys and values that become part of the query string. In this case, the key is always <code class="literal">term</code>, but the value is taken from the text of each link. Now, clicking on the first link in the list causes its definition to appear:</p><div class="mediaobject"><img src="graphics/3145OS_06_08.jpg" alt="Performing a GET request"/></div><p>All the links here have addresses given, even though we are not using them in the code. This provides an alternative method of <a id="id496" class="indexterm"/>navigating the information for users who have JavaScript turned off or unavailable (a form of progressive enhancement). To prevent the <a id="id497" class="indexterm"/>links from being followed normally when clicked, we invoke the <code class="literal">.preventDefault()</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>
<span class="strong"><strong>Return false or prevent default?</strong></span>
</p><p>When writing the <code class="literal">click</code> handlers in this chapter, we have chosen to pass the <code class="literal">event</code> object into the handler and use <code class="literal">event.preventDefault()</code> rather than ending the handler with <code class="literal">return false</code>. This practice is recommended when the default action would otherwise reload the page or load another page. If our <code class="literal">click</code> handler, for example, contains a JavaScript error, calling <code class="literal">.preventDefault()</code> on the handler's first line (before the error is encountered) ensures that the form will not be submitted, and our browser's error console will properly report the error. Remember from <a class="link" href="ch03.html" title="Chapter&#xA0;3.&#xA0;Handling Events">Chapter 3</a>, <span class="emphasis"><em>Handling Events</em></span>, that return <code class="literal">false</code> calls both <code class="literal">event.preventDefault()</code> and <code class="literal">event.stopPropagation()</code>. If we wanted to stop the event from bubbling, we would need to call the latter as well.</p></div></div></div><div class="section" title="Performing a POST request"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Performing a POST request</h2></div></div></div><p>HTTP requests using the <a id="id498" class="indexterm"/>POST method are almost identical to those using GET. One of the most visible differences is that GET places its arguments in the query string portion of the URL, whereas POST requests do not. However, in Ajax calls, even this <a id="id499" class="indexterm"/>distinction is invisible to the average user. Generally, the only reason to choose one method over the other is to conform to the norms of the server-side code, or to provide for large amounts of transmitted data; GET has a more stringent limit. We have coded our PHP example to cope equally well with either method, so we can change from GET to POST simply by changing the jQuery function we call:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-e a').click(function(event) {
    event.preventDefault();
    var requestData = {term: $(this).text()};
<span class="strong"><strong>    $.post('e.php', requestData, function(data) {</strong></span>
      $('#dictionary').html(data);
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.11</em></span>
</p><p>The arguments are the same, and the request will now be made via POST. We can further simplify the code by using the <code class="literal">.load()</code> method, which uses POST by default when it is supplied with a simple object containing data to pass along:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-e a').click(function(event) {
    event.preventDefault();
    var requestData = {term: $(this).text()};
    $('#dictionary').load('e.php', requestData);
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.12</em></span>
</p><p>This cut-down version functions the same way when a link is clicked. The dictionary entry appears on the right-hand side of the page, as before:</p><div class="mediaobject"><img src="graphics/3145OS_06_09.jpg" alt="Performing a POST request"/></div></div><div class="section" title="Serializing a form"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Serializing a form</h2></div></div></div><p>Sending data to the server <a id="id500" class="indexterm"/>often involves the user filling out forms. Rather than relying on the <a id="id501" class="indexterm"/>normal form submission mechanism, which will load the response in the entire browser window, we can use jQuery's Ajax toolkit to submit the form asynchronously and place the response inside the current page.</p><p>To try this out, we'll need to construct a simple form:</p><div class="informalexample"><pre class="programlisting">&lt;div class="letter" id="letter-f"&gt;
  &lt;h3&gt;F&lt;/h3&gt;
  &lt;form action="f.php"&gt;
    &lt;input type="text" name="term" value="" id="term" /&gt;
    &lt;input type="submit" name="search" value="search"
      id="search" /&gt;
  &lt;/form&gt;
&lt;/div&gt;</pre></div><p>This time, we'll return a set of entries from the server by using PHP to search for the supplied search term as a substring of a dictionary term. We'll use our <code class="literal">build_entry()</code> function from <code class="literal">e.php</code> to return the data in the same format as before, but we'll modify the logic somewhat in <code class="literal">f.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
$output = array();
foreach ($entries as $term =&gt; $entry) {
<span class="strong"><strong>  if (strpos($term, strtoupper($_REQUEST['term'])) !== FALSE) {</strong></span>
    $output[] = build_entry($term, $entry);
  }
}

if (!empty($output)) {
  echo implode("\n", $output);
} else {
  echo '&lt;div class="entry"&gt;Sorry, no entries found for ';
  echo '&lt;strong&gt;' . $_REQUEST['term'] . '&lt;/strong&gt;.';
  echo '&lt;/div&gt;';
}
?&gt;</pre></div><p>The call to <code class="literal">strpos()</code> scans the <a id="id502" class="indexterm"/>word for the supplied search string. Now we can react to a <a id="id503" class="indexterm"/>form submission and craft the proper query parameters by traversing the DOM tree:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-f form').submit(function(event) {
    event.preventDefault();
    $.get('f.php', {'term': $('input[name="term"]').val()}, 
      function(data) {
        $('#dictionary').html(data);
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.13</em></span>
</p><p>This code has the intended effect, but searching for input fields by name and appending them to a map one by one is cumbersome. In particular, this approach does not scale well as the form becomes more complex. Fortunately, jQuery offers a shortcut for this often-used idiom. The <code class="literal">.serialize()</code> <a id="id504" class="indexterm"/>method acts on a jQuery object and translates the matched DOM elements into a query string that can be passed along with an Ajax request. We can generalize our submission handler as follows:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#letter-f form').submit(function(event) {
    event.preventDefault();
<span class="strong"><strong>    var formValues = $(this).serialize();</strong></span>
    $.get('f.php', formValues, function(data) {
      $('#dictionary').html(data);
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 6.14</em></span>
</p><p>Now the same script will work to submit the form, even as the number of fields increases. When we perform a search for <code class="literal">fid</code>, for example, the terms containing that substring are displayed as shown in the <a id="id505" class="indexterm"/>following screenshot:</p><div class="mediaobject"><img src="graphics/3145OS_06_10.jpg" alt="Serializing a form"/></div></div></div></body></html>
