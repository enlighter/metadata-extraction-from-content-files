<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Observing and interrupting animations</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Observing and interrupting animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec85"/>Observing and interrupting animations</h1></div></div></div><p>Our basic animation already <a id="id885" class="indexterm"/>reveals a problem. As long as there is enough time for the animation to complete after each <code class="literal">mouseenter</code> or <code class="literal">mouseleave</code> event, the <a id="id886" class="indexterm"/>animations proceed as intended. When the mouse cursor moves rapidly and the events are triggered quickly, however, we see that the images also grow and shrink repeatedly, well after the last event is triggered. This occurs because, as discussed in <a class="link" href="ch04.html" title="Chapter&#xA0;4.&#xA0;Styling and Animating">Chapter 4</a>, <span class="emphasis"><em>Styling and Animating</em></span>, animations on a given element are added to a queue and called in order. The first animation is called immediately, completes in the allotted time, and then is shifted off of the queue, at which point the next animation becomes first in line, is called, completes, is shifted, and so on until the queue is empty.</p><p>There are many cases in which this animation queue, known within jQuery as <code class="literal">fx</code>, causes desirable behavior. In the case of hover actions such as ours, though, it needs to be circumvented.</p><div class="section" title="Determining the animation state"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec125"/>Determining the animation state</h2></div></div></div><p>One way to avoid the undesirable queuing of animations is to employ jQuery's custom <code class="literal">:animated</code> selector. Inside the <a id="id887" class="indexterm"/>
<code class="literal">mouseenter</code>/<code class="literal">mouseleave</code> event handler, we can use the selector to <a id="id888" class="indexterm"/>check the image and see if it is currently being animated:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('div.member').on('mouseenter mouseleave', function(event) {
<span class="strong"><strong>    var $image = $(this).find('img');</strong></span>
<span class="strong"><strong>    if (!$image.is(':animated') || event.type == 'mouseleave') {</strong></span>
      var size = event.type == 'mouseenter' ? 85 : 75;
      var padding = event.type == 'mouseenter' ? 0 : 5;
      $image.animate({
        width: size,
        height: size,
        paddingTop: padding,
        paddingLeft: padding
      });
<span class="strong"><strong>    }</strong></span>
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 11.2</em></span>
</p><p>When the user's mouse enters the member <code class="literal">&lt;div&gt;</code>, the image will only animate if it isn't already being animated. When the mouse leaves, the animation will occur regardless of its state because we always want it to ultimately restore the image to its original dimensions and padding.</p><p>We've successfully avoided the runaway animations that occur in <span class="emphasis"><em>Listing 11.1</em></span>, but the animations still need improvement. When the mouse quickly enters and leaves the <code class="literal">&lt;div&gt;</code> tag, the image still has to complete the entire <a id="id889" class="indexterm"/>
<code class="literal">mouseenter</code> animation (growing) before it starts the <code class="literal">mouseleave</code> animation (shrinking). This is not ideal, for sure, but the test of the <code class="literal">:animated</code> pseudo-class has introduced an even greater problem: if the mouse enters the <code class="literal">&lt;div&gt;</code> tag while the image is <span class="emphasis"><em>shrinking</em></span>, the image will fail to grow again. Only a subsequent <code class="literal">mouseleave</code> and <code class="literal">mouseenter</code> animation after the animation has stopped will execute another animation. While using the <code class="literal">:animated</code> selector can be useful in some situations, here it doesn't help enough.</p></div><div class="section" title="Halting a running animation"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec126"/>Halting a running animation</h2></div></div></div><p>Fortunately, jQuery has a method to help us <a id="id890" class="indexterm"/>with both of the problems evident in <span class="emphasis"><em>Listing 11.2</em></span>. The <code class="literal">.stop()</code> method can halt an animation in its tracks. To employ it, we can return the code to the way it was in <span class="emphasis"><em>Listing 11.1</em></span> and simply insert <code class="literal">.stop()</code> between <code class="literal">.find()</code> and <code class="literal">.animate()</code>:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('div.member').on('mouseenter mouseleave', function(event) {
    var size = event.type == 'mouseenter' ? 85 : 75;
    var padding = event.type == 'mouseenter' ? 0 : 5;
<span class="strong"><strong>    $(this).find('img').stop().animate({</strong></span>
      width: size,
      height: size,
      paddingTop: padding,
      paddingLeft: padding
    });
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 11.3</em></span>
</p><p>It's worth noting that we stop the current animation <span class="emphasis"><em>before</em></span> proceeding with the new one. Now when the mouse enters and leaves repeatedly, the undesirable effect of our previous attempts is gone. The current animation <a id="id891" class="indexterm"/>always completes immediately, so there is never more than one in the <code class="literal">fx</code> queue. When the mouse finally rests, the final animation completes, so the image is either fully grown (<code class="literal">mouseenter</code>) or restored to its original dimensions (<code class="literal">mouseleave</code>) depending on the last triggered event.</p><div class="section" title="Caution when halting animations"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec26"/>Caution when halting animations</h3></div></div></div><p>Because the <code class="literal">.stop()</code> method <a id="id892" class="indexterm"/>by default <a id="id893" class="indexterm"/>halts animations at their current position, it can lead to surprising results when used with shorthand animation methods. Before animating, these shorthand methods determine the final value and then animate to that value. For example, if <code class="literal">.slideDown()</code> is halted with <code class="literal">.stop()</code> midway through its animation and then <code class="literal">.slideUp()</code> is called, the next time <code class="literal">.slideDown()</code> is called on the element, it will only slide down to the height at which it stopped the previous time. To mitigate this type of problem, the <code class="literal">.stop()</code> method can accept two Boolean (<code class="literal">true</code>/<code class="literal">false</code>) arguments, the second of which is known as <code class="literal">goToEnd</code>. If we set this argument to <code class="literal">true</code>, the current animation not only stops, but also jumps immediately to the final value. Still, the <code class="literal">goToEnd</code> feature can make the animation look "jerky," so a better solution might be to store the final value in a variable and animate to it explicitly using <code class="literal">.animate()</code> rather than rely on jQuery to determine that value.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Another jQuery method, <code class="literal">.finish()</code>, is available for halting animations. It's similar to <code class="literal">.stop(true, true)</code> in that it clears all queued animations and jumps the current animation to the final value. However, unlike <code class="literal">.stop(true, true)</code>, it jumps all the <span class="emphasis"><em>queued</em></span> animations to their final values as well.</p></div></div></div></div></div></body></html>
