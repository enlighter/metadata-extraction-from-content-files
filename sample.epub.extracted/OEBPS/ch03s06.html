<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Simulating user interaction</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Simulating user interaction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Simulating user interaction</h1></div></div></div><p>At times, it is convenient to <a id="id254" class="indexterm"/>execute code that we have bound to an event, even if the normal circumstances of the event are not occurring. For example, suppose we wanted our style switcher to begin in its collapsed state. We could accomplish this by hiding buttons from within the stylesheet, or by adding our <code class="literal">hidden</code> class or calling the <code class="literal">.hide()</code> method from a <code class="literal">$(document).ready()</code> handler. Another way would be to simulate a click on the style switcher so that the toggling mechanism we've already established is triggered.</p><p>The <code class="literal">.trigger()</code> method allows us to do just this:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#switcher').trigger('click');
});</pre></div><p>
<span class="emphasis"><em>Listing 3.23</em></span>
</p><p>Now when the page loads, the switcher is collapsed just as if it had been clicked, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3145OS_03_10.jpg" alt="Simulating user interaction"/></div><p>If we were hiding content that <a id="id255" class="indexterm"/>we wanted people without JavaScript enabled to see, this would be a reasonable way to implement <span class="strong"><strong>graceful degradation</strong></span>.</p><p>The <code class="literal">.trigger()</code> method <a id="id256" class="indexterm"/>provides the same set of shortcut methods that <code class="literal">.on()</code> does. When these shortcuts are used with no arguments, the behavior is to trigger the action rather than bind it:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#switcher').click();
});</pre></div><p>
<span class="emphasis"><em>Listing 3.24</em></span>
</p><div class="section" title="Reacting to keyboard events"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Reacting to keyboard events</h2></div></div></div><p>As another example, we can <a id="id257" class="indexterm"/>add keyboard shortcuts to our style switcher. When the user types the first letter of one of the display styles, we will have the page behave as if the corresponding button was clicked. To implement this feature, we will need to explore <span class="strong"><strong>keyboard events</strong></span>, which behave a bit differently from <span class="strong"><strong>mouse events</strong></span>.</p><p>There are two types of keyboard events: those that react to the keyboard directly (<code class="literal">keyup</code> and <code class="literal">keydown</code>) and those that react to text input (<code class="literal">keypress</code>). A single character entry event could correspond to several keys, for example, when the <span class="emphasis"><em>Shift</em></span> key in combination with the <span class="emphasis"><em>X</em></span> key creates the capital letter <span class="strong"><strong>X</strong></span>. While the specifics of implementation differ from one browser to the next (unsurprisingly), a safe rule of thumb is: if you want to know what key the user pushed, you should observe the <code class="literal">keyup</code> or <code class="literal">keydown</code> event; if you want to know what character ended up on the screen as a result, you should observe the <code class="literal">keypress</code> event. For this feature, we just want to know when the user presses the <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>N</em></span>, or <span class="emphasis"><em>L</em></span> key, so we will use <code class="literal">keyup</code>.</p><p>Next, we need to determine which element should watch for the event. This is a little less obvious than with mouse events, where we have a visible mouse cursor to tell us about the event's target. Instead, the target of a keyboard event is the element that currently has the <span class="strong"><strong>keyboard focus</strong></span>. The element with <a id="id258" class="indexterm"/>focus can be changed in several ways, including using mouse clicks and pressing the <span class="emphasis"><em>Tab</em></span> key. Not every element can get the focus, either; only items that have default keyboard-driven behaviors such as form fields, links, and elements with a <code class="literal">.tabIndex</code> property are candidates.</p><p>In this case, we don't really care what element has the focus; we want our switcher to work whenever the user presses one of the keys. Event bubbling will once again come in handy, as we can bind our <code class="literal">keyup</code> event to the <code class="literal">document</code> element and have assurance that eventually any key event will bubble up to us.</p><p>Finally, we will need to know which key was pressed when our <code class="literal">keyup</code> handler gets triggered. We can inspect the <code class="literal">event</code> object for this. <a id="id259" class="indexterm"/>The <code class="literal">.which</code> property of the event contains an identifier for the key that was pressed, and for alphabetic keys, this identifier is the ASCII value of the uppercase letter. <a id="id260" class="indexterm"/>With this information, we can now create an <span class="strong"><strong>object literal</strong></span> of letters and their corresponding buttons to click. When the user presses a key, we'll see if its identifier is in the map, and if so, trigger the click:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var triggers = {
    D: 'default',
    N: 'narrow',
    L: 'large'
  };
  $(document).keyup(function(event) {
    var key = String.fromCharCode(event.which);
    if (key in triggers) {
      $('#switcher-' + triggers[key]).click();
    }
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 3.25</em></span>
</p><p>Presses of these three keys now simulate mouse clicks on the buttons&#x2014;provided that the key event is not interrupted by features such as Firefox's <span class="strong"><strong>search for text when I start typing</strong></span>.</p><p>As an alternative to using <code class="literal">.trigger()</code> to simulate this click, let's explore how to factor out code into a function so that more than one handler can call it in this case, both <code class="literal">click</code> and <code class="literal">keyup</code> handlers. While not necessary in this case, this technique can be useful in eliminating code redundancy:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  // Enable hover effect on the style switcher
  $('#switcher').hover(function() {
    $(this).addClass('hover');
  }, function() {
    $(this).removeClass('hover');
  });
  // Allow the style switcher to expand and collapse
  var toggleSwitcher = function(event) {
    if (!$(event.target).is('button')) {
      $('#switcher button').toggleClass('hidden');
    }
  };
  $('#switcher').on('click', toggleSwitcher);
  // Simulate a click so we start in a collapsed state
  $('#switcher').click();
  // The setBodyClass() function changes the page style
  // The style switcher state is also updated
  var setBodyClass = function(className) {
    $('body').removeClass().addClass(className);
    $('#switcher button').removeClass('selected');
    $('#switcher-' + className).addClass('selected');
    $('#switcher').off('click', toggleSwitcher);
    if (className == 'default') {
      $('#switcher').on('click', toggleSwitcher);
    }
  };
  // Begin with the switcher-default button "selected"
  $('#switcher-default').addClass('selected');
  // Map key codes to their corresponding buttons to click
  var triggers = {
    D: 'default',
    N: 'narrow',
    L: 'large'
  };
  // Call setBodyClass() when a button is clicked
  $('#switcher').click(function(event) {
    if ($(event.target).is('button')) {
      var bodyClass = event.target.id.split('-')[1];
      setBodyClass(bodyClass);
    }
  });
  // Call setBodyClass() when a key is pressed
  $(document).keyup(function(event) {
    var key = String.fromCharCode(event.keyCode);
    if (key in triggers) {
      setBodyClass(triggers[key]);
    }
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 3.26</em></span>
</p><p>This final revision consolidates all the previous code examples of this chapter. We have moved the entire block of code into a single <code class="literal">$(document).ready()</code> handler and made our code less redundant.</p></div></div></body></html>
