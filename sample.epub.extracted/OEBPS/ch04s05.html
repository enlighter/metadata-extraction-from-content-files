<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Simultaneous versus queued effects</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Simultaneous versus queued effects"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Simultaneous versus queued effects</h1></div></div></div><p>The <code class="literal">.animate()</code> method, as <a id="id340" class="indexterm"/>
<a id="id341" class="indexterm"/>we've just discovered, is very useful for creating simultaneous effects affecting a particular set of elements. There may be times, however, when we want to queue our <a id="id342" class="indexterm"/>
<a id="id343" class="indexterm"/>effects to have them occur one after the other.</p><div class="section" title="Working with a single set of elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Working with a single set of elements</h2></div></div></div><p>When applying multiple effects to the <a id="id344" class="indexterm"/>same set of elements, queuing is easily achieved by chaining those effects. To demonstrate this queuing, we'll revisit <span class="emphasis"><em>Listing 4.17</em></span> by moving the <span class="strong"><strong>Text Size</strong></span> box to the right-hand side, increasing its height and border width. This time, however, we perform the three effects sequentially simply by placing each in its own <code class="literal">.animate()</code> method and chaining the three together:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('div.label').click(function() {
    var paraWidth = $('div.speech p').outerWidth();
    var $switcher = $(this).parent();
    var switcherWidth = $switcher.outerWidth();
    $switcher
      .css({position: 'relative'})
<span class="strong"><strong>      .animate({left: paraWidth - switcherWidth}, 'slow')</strong></span>
<span class="strong"><strong>      .animate({height: '+=20px'}, 'slow')</strong></span>
<span class="strong"><strong>      .animate({borderWidth: '5px'}, 'slow');</strong></span>
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 4.18</em></span>
</p><p>Recall that chaining permits us to keep all three <code class="literal">.animate()</code> methods on the same line, but here we have indented them and put each on its own line for greater readability.</p><p>We can queue any of the jQuery effect methods by chaining them, not just <code class="literal">.animate()</code>. We could, for example, queue effects on <code class="literal">&lt;div id="switcher"&gt;</code> in the following order:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Fade its opacity to 0.5 with <code class="literal">.fadeTo()</code>.</li><li class="listitem">Move it to the right-hand side with <code class="literal">.animate()</code>.</li><li class="listitem">Fade it back in to full opacity with <code class="literal">.fadeTo()</code>.</li><li class="listitem">Hide it with <code class="literal">.slideUp()</code>.</li><li class="listitem">Show it once more with <code class="literal">.slideDown()</code>.</li></ol></div><p>All we need to do is chain the effects in the same order in our code:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('div.label').click(function() {
    var paraWidth = $('div.speech p').outerWidth();
    var $switcher = $(this).parent();
    var switcherWidth = $switcher.outerWidth();
    $switcher
      .css({position: 'relative'})
      .fadeTo('fast', 0.5)
      .animate({left: paraWidth - switcherWidth}, 'slow')
      .fadeTo('slow', 1.0)
      .slideUp('slow')
      .slideDown('slow');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 4.19</em></span>
</p><div class="section" title="Bypassing the queue"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Bypassing the queue</h3></div></div></div><p>But what if we want to move the <code class="literal">&lt;div&gt;</code> tag to the right-hand side at the same time as it fades to half opacity? If the two <a id="id345" class="indexterm"/>animations were occurring at the same speed, we could simply combine them into a single <code class="literal">.animate()</code> method. But, in this example, the fade is using the <code class="literal">'fast'</code> speed while the move to the right-hand side is using the <code class="literal">'slow'</code> speed. Here is where the second form of the <code class="literal">.animate()</code> method comes in handy:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('div.label').click(function() {
    var paraWidth = $('div.speech p').outerWidth();
    var $switcher = $(this).parent();
    var switcherWidth = $switcher.outerWidth();
    $switcher
      .css({position: 'relative'})
      .fadeTo('fast', 0.5)
      .animate({
        left: paraWidth - switcherWidth
      }, {
        duration: 'slow',
        queue: false
      })
      .fadeTo('slow', 1.0)
      .slideUp('slow')
      .slideDown('slow');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 4.20</em></span>
</p><p>The second argument, an options object, provides the <span class="strong"><strong>queue</strong></span> option, which when set to <code class="literal">false</code> makes the animation start simultaneously with the previous one.</p></div><div class="section" title="Queuing effects manually"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Queuing effects manually</h3></div></div></div><p>One final observation about <a id="id346" class="indexterm"/>queuing effects on a single set of elements is that queuing does not automatically apply to other non-effect methods such as .<code class="literal">css()</code>. So, let's suppose we wanted to change the background color of <code class="literal">&lt;div id="switcher"&gt;</code> to red after the <code class="literal">.slideUp()</code> method, but before the <code class="literal">slideDown()</code> method.</p><p>We could try doing it like this:</p><div class="informalexample"><pre class="programlisting">// Unfinished code
$(document).ready(function() {
  $('div.label').click(function() {
    var paraWidth = $('div.speech p').outerWidth();
    var $switcher = $(this).parent();
    var switcherWidth = $switcher.outerWidth();
    $switcher
      .css({position: 'relative'})
      .fadeTo('fast', 0.5)
      .animate({
        left: paraWidth - switcherWidth
      }, {
        duration: 'slow',
        queue: false
      })
      .fadeTo('slow', 1.0)
      .slideUp('slow')
      .css({backgroundColor: '#f00'})
      .slideDown('slow');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 4.21</em></span>
</p><p>However, even though the background-changing code is placed at the correct position in the chain, it occurs immediately upon the click.</p><p>One way we can add non-effect methods to the queue is to use the appropriately named .<code class="literal">queue()</code> method. Here is what it would look like in our example:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('div.label').click(function() {
    var paraWidth = $('div.speech p').outerWidth();
    var $switcher = $(this).parent();
    var switcherWidth = $switcher.outerWidth();
    $switcher
      .css({position: 'relative'})
      .fadeTo('fast', 0.5)
      .animate({
        left: paraWidth - switcherWidth
      }, {
        duration: 'slow',
        queue: false
      })
      .fadeTo('slow', 1.0)
      .slideUp('slow')
<span class="strong"><strong>      .queue(function(next) {</strong></span>
<span class="strong"><strong>        $switcher.css({backgroundColor: '#f00'});</strong></span>
<span class="strong"><strong>        next();</strong></span>
<span class="strong"><strong>      })</strong></span>
      .slideDown('slow');
  });&#x2029;});</pre></div><p>
<span class="emphasis"><em>Listing 4.22</em></span>
</p><p>When given a callback function, as it is here, the .<code class="literal">queue()</code> method adds the function to the queue of effects to perform on <a id="id347" class="indexterm"/>the matched elements. Within the function, we set the background color to red and then call <code class="literal">next()</code>, a function that is <a id="id348" class="indexterm"/>passed as a parameter to our callback. Including this <code class="literal">next()</code> function call allows the animation queue to pick up where it left off and complete the chain with the following <code class="literal">.slideDown('slow')</code> line. If we hadn't called <code class="literal">next()</code>, the animation would have stopped.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>For more information and examples of <code class="literal">.queue()</code>, visit <a class="ulink" href="http://api.jquery.com/category/effects/">http://api.jquery.com/category/effects/</a>.</p></div></div><p>We'll discover another way to queue noneffect methods as we examine effects with multiple sets of elements.</p></div></div><div class="section" title="Working with multiple sets of elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Working with multiple sets of elements</h2></div></div></div><p>Unlike with a single set of <a id="id349" class="indexterm"/>elements, when we apply effects to different sets, they occur at virtually the same time. To see these simultaneous effects in action, we'll slide one paragraph down while sliding another paragraph up. We'll be working with paragraphs three and four of our sample document:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;Fourscore and seven years ago our fathers brought forth
   on this continent a new nation, conceived in liberty,
   and dedicated to the proposition that all men are
   created equal.&lt;/p&gt;
&lt;p&gt;Now we are engaged in a great civil war, testing whether
   that nation, or any nation so conceived and so
   dedicated, can long endure. We are met on a great
   battlefield of that war. We have come to dedicate a
   portion of that field as a final resting-place for those
   who here gave their lives that the nation might live. It
   is altogether fitting and proper that we should do this.
   But, in a larger sense, we cannot dedicate, we cannot
   consecrate, we cannot hallow, this ground.&lt;/p&gt;
&lt;a href="#" class="more"&gt;read more&lt;/a&gt;
&lt;p&gt;The brave men, living and dead, who struggled here have
   consecrated it, far above our poor power to add or
   detract. The world will little note, nor long remember,
   what we say here, but it can never forget what they did
   here. It is for us the living, rather, to be dedicated
   here to the unfinished work which they who fought here
   have thus far so nobly advanced.&lt;/p&gt;
&lt;p&gt;It is rather for us to be here dedicated to the great
   task remaining before us&#x2014;that from these honored
   dead we take increased devotion to that cause for which
   they gave the last full measure of devotion&#x2014;that
   we here highly resolve that these dead shall not have
   died in vain&#x2014;that this nation, under God, shall
   have a new birth of freedom and that government of the
   people, by the people, for the people, shall not perish
   from the earth.&lt;/p&gt;</pre></div><p>To help us see what's happening <a id="id350" class="indexterm"/>during the effect, we'll give the third paragraph a 1-pixel border and the fourth paragraph a gray background. We'll also hide the fourth paragraph when the DOM is ready:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('p').eq(2).css('border', '1px solid #333');
  $('p').eq(3).css('backgroundColor', '#ccc').hide();
});</pre></div><p>
<span class="emphasis"><em>Listing 4.23</em></span>
</p><p>Our sample document now displays the opening paragraph followed by the <span class="strong"><strong>read more</strong></span> link and the bordered paragraph:</p><div class="mediaobject"><img src="graphics/3145OS_04_11.jpg" alt="Working with multiple sets of elements"/></div><p>Finally, we'll apply a <code class="literal">click</code> handler to the third paragraph so that when it is clicked, the third paragraph will slide up (and <a id="id351" class="indexterm"/>eventually out of view) while the fourth paragraph slides down (and into view):</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('p').eq(2)
    .css('border', '1px solid #333')
    .click(function() {
      $(this).slideUp('slow').next().slideDown('slow');
    });
  $('p').eq(3).css('backgroundColor', '#ccc').hide();
});</pre></div><p>
<span class="emphasis"><em>Listing 4.24</em></span>
</p><p>A screenshot of these two effects in mid-slide confirms that they do, indeed, occur simultaneously:</p><div class="mediaobject"><img src="graphics/3145OS_04_12.jpg" alt="Working with multiple sets of elements"/></div><p>The third paragraph, which started visible, is halfway through sliding up at the same time as the fourth paragraph, which started hidden, is halfway through sliding down.</p><div class="section" title="Queuing with callbacks"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Queuing with callbacks</h3></div></div></div><p>In order to allow queuing <a id="id352" class="indexterm"/>effects on different elements, jQuery provides a <a id="id353" class="indexterm"/>callback function for each effect method. As we have seen with event handlers and with the <a id="id354" class="indexterm"/>
<code class="literal">.queue()</code> method, callbacks are simply functions passed as method arguments. In the case of effects, they appear as the last argument of the method.</p><p>If we use a callback to queue the two slide effects, we can have the fourth paragraph slide down before the third paragraph slides up. Let's first try moving the <code class="literal">.slideUp()</code> call into the .<code class="literal">slideDown()</code> method's completion callback:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('p').eq(2)
    .css('border', '1px solid #333')
    .click(function() {
      $(this).next().slideDown('slow', function() {
        $(this).slideUp('slow'); 
      });
    });
  $('p').eq(3).css('backgroundColor', '#ccc').hide();
 });</pre></div><p>
<span class="emphasis"><em>Listing 4.25</em></span>
</p><p>We do need to be careful here, however, about what is actually going to slide up. The context of the function&#x2014;the reserved word <code class="literal">this</code>&#x2014;is different because the callback is inside the <code class="literal">.slideDown()</code> method. Here, <code class="literal">$(this)</code> is no longer the third paragraph, as it was directly within the <code class="literal">click</code> handler; rather, since the <code class="literal">.slideDown()</code> method is being called on the result of <code class="literal">$(this).next()</code>, <a id="id355" class="indexterm"/>the callback within that method now sees <code class="literal">$(this)</code> as the next sibling or the fourth paragraph. Therefore, if we put <code class="literal">$(this).slideUp('slow')</code> inside the callback, as we have in <span class="emphasis"><em>Listing 4.25</em></span>, we would end up hiding the same paragraph that we had just made visible.</p><p>A simple way to keep the <code class="literal">$(this)</code> reference stable is to store it in a variable at the beginning of the <code class="literal">click</code> handler, such as <code class="literal">var $clickedItem = $(this)</code>.</p><p>Now, <code class="literal">$clickedItem</code> will refer to the third paragraph, both outside and inside the effect method callback. Here is what the code looks like using our new variable:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('p').eq(2)
    .css('border', '1px solid #333')
    .click(function() {
      var $clickedItem = $(this);
      $clickedItem.next().slideDown('slow', function() {
       $clickedItem.slideUp('slow'); 
      });
    });
  $('p').eq(3).css('backgroundColor', '#ccc').hide();
});</pre></div><p>
<span class="emphasis"><em>Listing 4.26</em></span>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>Using <code class="literal">$clickedItem</code> inside the <code class="literal">.slideDown()</code> callback relies on the properties of closures. We'll be discussing this important yet difficult-to-master topic in <a class="link" href="apa.html" title="Appendix&#xA0;A.&#xA0;JavaScript Closures">Appendix A</a>, <span class="emphasis"><em>JavaScript Closures</em></span>.</p></div></div><p>This time, a snapshot halfway through the effects will reveal that both the third and the fourth paragraphs are visible; the <a id="id356" class="indexterm"/>fourth has finished sliding down and the third is about to begin sliding up:</p><div class="mediaobject"><img src="graphics/3145OS_04_13.jpg" alt="Queuing with callbacks"/></div><p>Now that we've discussed callbacks, we can return to the code from <span class="emphasis"><em>Listing 4.22</em></span>, in which we queued a background-color change near the end of a series of effects. Instead of using the <code class="literal">.queue()</code> method, as we did then, we can simply use a callback function:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('div.label').click(function() {
    var paraWidth = $('div.speech p').outerWidth();
    var $switcher = $(this).parent();
    var switcherWidth = $switcher.outerWidth();
    $switcher
      .css({position: 'relative'})
      .fadeTo('fast', 0.5)
      .animate({
        left: paraWidth - switcherWidth
      }, {
        duration: 'slow',
        queue: false
      })
      .fadeTo('slow', 1.0)
      .slideUp('slow', function() {
        $switcher.css({backgroundColor: '#f00'});
      })
      .slideDown('slow');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 4.27</em></span>
</p><p>Here again, the background color of <code class="literal">&lt;div id="switcher"&gt;</code> changes to red after it slides up and before it slides back <a id="id357" class="indexterm"/>down. Note that when using an effect's completion callback rather than <code class="literal">.queue()</code>, we don't need to worry about calling <code class="literal">next()</code> from within the callback.</p></div></div><div class="section" title="In a nutshell"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>In a nutshell</h2></div></div></div><p>With all the variations to consider when applying effects, it can become difficult to remember whether the effects will occur simultaneously or sequentially. A brief outline might help.</p><p>Effects on a single set of <a id="id358" class="indexterm"/>elements are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simultaneous when applied as multiple properties in a single .<code class="literal">animate()</code> method</li><li class="listitem" style="list-style-type: disc">Queued when applied in a chain of methods, unless the <code class="literal">queue</code> option is set to <code class="literal">false</code></li></ul></div><p>Effects on multiple sets of <a id="id359" class="indexterm"/>elements are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simultaneous by default</li><li class="listitem" style="list-style-type: disc">Queued when applied within the callback of another effect or within the callback of the <code class="literal">.queue()</code> method</li></ul></div></div></div></body></html>
