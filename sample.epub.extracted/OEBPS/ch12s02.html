<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Moving and inserting elements revisited</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Moving and inserting elements revisited"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec93"/>Moving and inserting elements revisited</h1></div></div></div><p>Over the course of the coming examples, we will build a flexible sorting mechanism that works on each of the columns. To do this, we will use the jQuery DOM manipulation methods to insert some new elements and move other existing elements to new homes. We will start with the most straightforward piece of the puzzle: linking the table headers.</p><div class="section" title="Adding links around existing text"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec134"/>Adding links around existing text</h2></div></div></div><p>We'd like to turn the <a id="id943" class="indexterm"/>table headers into links that sort the data by <a id="id944" class="indexterm"/>their respective columns. We can use jQuery's <code class="literal">.wrapInner()</code> <a id="id945" class="indexterm"/>method to add them; we recall from <a class="link" href="ch05.html" title="Chapter&#xA0;5.&#xA0;Manipulating the DOM">Chapter 5</a>, <span class="emphasis"><em>Manipulating the DOM</em></span>, that <code class="literal">.wrapInner()</code> places a new element (in this case an <code class="literal">&lt;a&gt;</code> element) <span class="emphasis"><em>inside</em></span> the matched element, but <span class="emphasis"><em>around</em></span> child elements:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var $table1 = $('#t-1');
  var $headers = $table1.find('thead th').slice(1);
  $headers
    .wrapInner('&lt;a href="#"&gt;&lt;/a&gt;')
    .addClass('sort');
});</pre></div><p>
<span class="emphasis"><em>Listing 12.1</em></span>
</p><p>We skipped the first <code class="literal">&lt;th&gt;</code> element of each table (using <code class="literal">.slice()</code>) because it contains no text other than white space, as <a id="id946" class="indexterm"/>there is no need to either label or sort the cover photos. We then added a class of <code class="literal">sort</code> to the remaining <code class="literal">&lt;th&gt;</code> elements so we can distinguish them in our CSS from their non-sortable counterparts. Now the header rows look like so:</p><div class="mediaobject"><img src="graphics/3145OS_12_02.jpg" alt="Adding links around existing text"/></div><p>This is an example of progressive <a id="id947" class="indexterm"/>enhancement's counterpart, <span class="strong"><strong>graceful degradation</strong></span>. Unlike the Ajax solution discussed earlier, this technique cannot function without JavaScript; we are assuming the server has no scripting language available to it for the purposes of this example. Since JavaScript is required for the sort to work, we are adding the <code class="literal">sort</code> class and the anchors through code only, thereby making sure that the interface indicates that sorting is possible only if the script can run. And since we're actually creating links rather than simply adding visual styles to indicate that the headers can be clicked, we provide the added benefit of accessibility for users who need to navigate to the headers with the keyboard (by <a id="id948" class="indexterm"/>pressing the <span class="emphasis"><em>Tab</em></span> key). The page <a id="id949" class="indexterm"/>
<span class="strong"><strong>degrades</strong></span> into one that is still functional, albeit without sorting available.</p></div><div class="section" title="Sorting simple JavaScript arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec135"/>Sorting simple JavaScript arrays</h2></div></div></div><p>To perform the sort, we <a id="id950" class="indexterm"/>will be taking advantage of JavaScript's built-in <code class="literal">.sort()</code> method. It does an in-place sort on an array, and can take a <span class="strong"><strong>comparator </strong></span>
<a id="id951" class="indexterm"/>
<span class="strong"><strong>function</strong></span> as an argument. This function compares two items in the array and should return a <a id="id952" class="indexterm"/>positive or negative number depending on which item should come first in the sorted array.</p><p>For example, take a simple array of numbers:</p><div class="informalexample"><pre class="programlisting">var arr = [52, 97, 3, 62, 10, 63, 64, 1, 9, 3, 4];</pre></div><p>We can sort this array by calling <a id="id953" class="indexterm"/>
<code class="literal">arr.sort()</code>. After this, the items are in the following order:</p><div class="informalexample"><pre class="programlisting">[1, 10, 3, 3, 4, 52, 62, 63, 64, 9, 97]</pre></div><p>By default, as we see here, the items are sorted <a id="id954" class="indexterm"/>
<span class="strong"><strong>lexicographically</strong></span> (in alphabetical order). In this case, it might make more sense to sort the items <span class="emphasis"><em>numerically</em></span>. To do this, we can supply a comparator <a id="id955" class="indexterm"/>function to the <code class="literal">.sort()</code> method:</p><div class="informalexample"><pre class="programlisting">arr.sort(function(a,b) {
  if (a &lt; b) {
    return -1;&#x2029;  }
  if (a &gt; b) {
    return 1;
  }
  return 0;
});</pre></div><p>This function returns a negative number if <code class="literal">a</code> should come first in the sorted array, a positive number if <code class="literal">b</code> should come first, and zero if the order of the items does not matter. With this information in hand, the <code class="literal">.sort()</code> <a id="id956" class="indexterm"/>method can sequence the items appropriately:</p><div class="informalexample"><pre class="programlisting">[1, 3, 3, 4, 9, 10, 52, 62, 63, 64, 97]</pre></div><p>We will next apply this <code class="literal">.sort()</code> method to our table rows.</p></div><div class="section" title="Sorting DOM elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec136"/>Sorting DOM elements</h2></div></div></div><p>Let's perform a sort on the <code class="literal">Title</code> <a id="id957" class="indexterm"/>column of the table. Note that while we added the <a id="id958" class="indexterm"/>
<code class="literal">sort</code> class to it and the others, this column's header cell already has a <a id="id959" class="indexterm"/>
<code class="literal">sort-alpha</code> class provided by the HTML. The other header cells received similar treatment depending on the type of sorting for each, but for now we'll focus on the <code class="literal">Title</code> header, which requires a straightforward alphabetic sort:</p><div class="informalexample"><pre class="programlisting">$headers.on('click', function(event) {
  event.preventDefault();
var column = $(this).index();
var rows = $table1.find('tbody &gt; tr').get();
     rows.sort(function(a, b) {
    var keyA = $(a).children('td').eq(column).text();
keyA = $.trim(keyA).toUpperCase();
var keyB = $(b).children('td').eq(column).text();
    keyB = $.trim(keyB).toUpperCase();
    if (keyA &lt; keyB) return -1;
    if (keyA &gt; keyB) return 1;
    return 0;
  });

  $.each(rows, function(index, row) {
    $table1.children('tbody').append(row);
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 12.2</em></span>
</p><p>Once we have found the index of the clicked header cell, we retrieve an array of all the data rows. This is a great example of how <code class="literal">.get()</code> is useful in transforming a jQuery object into an array of DOM <a id="id960" class="indexterm"/>nodes; even though jQuery objects act like arrays in many respects, they don't have all of the native array methods available, such as <code class="literal">.pop()</code> or <code class="literal">.shift()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Internally, jQuery actually does define a few methods that act like native array methods. For example, <code class="literal">.sort()</code>, <code class="literal">.push()</code>, and <code class="literal">.splice()</code> are methods of jQuery objects. However, since these methods are for internal use and not publicly documented, we cannot rely on them behaving in expected ways in our own code, and should thus avoid calling them on jQuery objects.</p></div></div><p>Now that we have an array of DOM nodes, we can sort them, but to do this we need to write an appropriate comparator function. We want to sort the rows according to the textual contents of the relevant table cells, so this will be the information the comparator function will examine. We know which cell to look at because we captured the column index with the <code class="literal">.index()</code>
<a id="id961" class="indexterm"/> call. We use jQuery's <a id="id962" class="indexterm"/>
<code class="literal">$.trim()</code> function to strip out leading and trailing white space, and then we convert the text to uppercase because string comparisons in JavaScript are case-sensitive while our sort should be case-insensitive. We store the key values in variables to avoid redundant calculations, compare them, and return <code class="literal">1</code> or <code class="literal">-1</code>, just as we did when sorting a simple array of numbers before.</p><p>Our array is now sorted, but note that the call to <a id="id963" class="indexterm"/>
<code class="literal">.sort()</code> has not changed the DOM itself. To do this, we need to call DOM manipulation methods to move the rows around. We do this one row at a time, reinserting each into the table as we loop through them. Since <code class="literal">.append()</code> does not clone <a id="id964" class="indexterm"/>nodes, this <span class="emphasis"><em>moves</em></span> them rather than copying them. Our table is now sorted:</p><div class="mediaobject"><img src="graphics/3145OS_12_03.jpg" alt="Sorting DOM elements"/></div></div></div></body></html>
