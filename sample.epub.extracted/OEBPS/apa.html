<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Appendix&#xA0;A.&#xA0;JavaScript Closures</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="appendix" title="Appendix&#xA0;A.&#xA0;JavaScript Closures"><div class="titlepage"><div><div><h1 class="title"><a id="appA"/>Appendix&#xA0;A.&#xA0;JavaScript Closures</h1></div></div></div><p>Throughout this book, we have seen many jQuery methods that take functions as parameters. Our examples have thus created, called, and passed around functions time and again. While usually we can do this with only a cursory understanding of the inner JavaScript mechanics at work, at times side effects of our actions can seem strange if we do not have knowledge of the language's features. In this appendix, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JavaScript's ability to define functions within other functions</li><li class="listitem" style="list-style-type: disc">Ways in which function objects can be passed around</li><li class="listitem" style="list-style-type: disc">The scope of variables defined inside and outside functions</li><li class="listitem" style="list-style-type: disc">Common problems caused by variable scoping and closures</li><li class="listitem" style="list-style-type: disc">How jQuery constructs interact with function definitions</li><li class="listitem" style="list-style-type: disc">Memory issues that can be caused by the interactions between functions</li></ul></div><div class="section" title="Creating inner functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec107"/>Creating inner functions</h1></div></div></div><p>JavaScript is fortunate to number <a id="id1099" class="indexterm"/>itself among the programming languages that support inner function declarations. Many traditional programming languages, such as C, collect all functions in a single top-level scope. Languages with inner functions, on the other hand, allow us to gather small utility functions where they are needed, avoiding namespace pollution.</p><p>An inner function is simply a function that is defined inside of another function. For example:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
  function innerFn() {
  }
}</pre></div><p>
<span class="emphasis"><em>Listing A.1</em></span>
</p><p>Here, <code class="literal">innerFn()</code> is an inner function, contained within the scope of <code class="literal">outerFn()</code>. This means that a call to <a id="id1100" class="indexterm"/>
<code class="literal">innerFn()</code> is valid within <code class="literal">outerFn()</code>, but not outside of it. <a id="id1101" class="indexterm"/>The following code results in a JavaScript error:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
<span class="strong"><strong>  console.log('Outer function');</strong></span>
  function innerFn() {
<span class="strong"><strong>    console.log('Inner Function');</strong></span>
  }
}
<span class="strong"><strong>console.log('innerFn():');</strong></span>
<span class="strong"><strong>innerFn();</strong></span>
</pre></div><p>
<span class="emphasis"><em>Listing A.2</em></span>
</p><p>We can successfully <a id="id1102" class="indexterm"/>run the code, <a id="id1103" class="indexterm"/>though, <a id="id1104" class="indexterm"/>by calling <code class="literal">innerFn()</code> from within <code class="literal">outerFn()</code>:</p><div class="informalexample"><pre class="programlisting">
function outerFn() {
  console.log('Outer function');
  function innerFn() {
    console.log('Inner function');
  }
<span class="strong"><strong>  innerFn();</strong></span>
}
<span class="strong"><strong>console.log('outerFn():');</strong></span>
<span class="strong"><strong>outerFn();</strong></span>
</pre></div><p>
<span class="emphasis"><em>Listing A.3</em></span>
</p><p>This results in the following output:</p><div class="informalexample"><pre class="programlisting">outerFn():
Outer function
Inner function</pre></div><p>This technique is especially handy for small, single-purpose functions. For example, algorithms that are recursive, but have a nonrecursive API wrapper, are often best expressed with an inner function as a helper.</p><div class="section" title="Calling inner functions from elsewhere"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec152"/>Calling inner functions from elsewhere</h2></div></div></div><p>The plot thickens when function <a id="id1105" class="indexterm"/>references come into play. Some languages, such as Pascal, allow the use of inner functions for the purpose of code hiding only; those functions are forever entombed within their parent functions. JavaScript, on the other hand, allows us to pass functions around just as if they were any other kind of data. This means inner functions can escape their captors.</p><p>The escape route can wind in <a id="id1106" class="indexterm"/>many different directions. For example, suppose the function is assigned to a global variable:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var globalVar;</strong></span>

function outerFn() {
  console.log('Outer function');
  function innerFn() {
    console.log('Inner function');
  }
<span class="strong"><strong>  globalVar = innerFn;</strong></span>
}
console.log('outerFn():');
outerFn();
<span class="strong"><strong>console.log('globalVar():');</strong></span>
<span class="strong"><strong>globalVar();</strong></span>
</pre></div><p>
<span class="emphasis"><em>Listing A.4</em></span>
</p><p>The call to <code class="literal">outerFn()</code> after the function definition modifies the global variable <code class="literal">globalVar</code>. It is now a reference to <code class="literal">innerFn()</code>. This means that the later call to <code class="literal">globalVar()</code> operates just as an inner call to <code class="literal">innerFn()</code> would, and the print statements are reached:</p><div class="informalexample"><pre class="programlisting">outerFn():
Outer function
globalVar():
Inner function</pre></div><p>Note that a call to <code class="literal">innerFn()</code> from outside of <code class="literal">outerFn()</code> still results in an error. Though the function has escaped by way of the reference stored in the global variable, the function name is still trapped inside the scope of <code class="literal">outerFn()</code>.</p><p>A function reference can also find its way out of a parent function through a return value:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
  console.log('Outer function');
  function innerFn() {
    console.log('Inner function');
  }
<span class="strong"><strong>  return innerFn;</strong></span>
}
<span class="strong"><strong>console.log('var fnRef = outerFn():');</strong></span>
<span class="strong"><strong>var fnRef = outerFn();</strong></span>
<span class="strong"><strong>console.log('fnRef():');</strong></span>
<span class="strong"><strong>fnRef();</strong></span>
</pre></div><p>
<span class="emphasis"><em>Listing A.5</em></span>
</p><p>Here, there is no global variable modified inside <code class="literal">outerFn()</code>. Instead, <code class="literal">outerFn()</code> returns a reference to <code class="literal">innerFn()</code>. The call to <code class="literal">outerFn()</code> results in this reference, which is stored and called itself in turn, triggering the message again:</p><div class="informalexample"><pre class="programlisting">var fnRef = outerFn():
Outer function
fnRef():
Inner function</pre></div><p>The fact that inner functions can be invoked through a reference even after the function has gone out of scope means that JavaScript needs to keep referenced functions available as long as they could possibly be <a id="id1107" class="indexterm"/>called. Each variable that refers to the function is tracked by the JavaScript runtime, and once the last has gone away, the JavaScript garbage collector comes along and frees up that bit of memory.</p></div><div class="section" title="Understanding variable scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec153"/>Understanding variable scope</h2></div></div></div><p>Inner functions can of <a id="id1108" class="indexterm"/>course have <a id="id1109" class="indexterm"/>their own variables, which are restricted in scope to the function itself:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
  function innerFn() {
<span class="strong"><strong>    var innerVar = 0;</strong></span>
<span class="strong"><strong>    innerVar++;</strong></span>
<span class="strong"><strong>    console.log('innerVar = ' + innerVar);</strong></span>
  }
  return innerFn;
}
var fnRef = outerFn();
fnRef();
fnRef();
var fnRef2 = outerFn();
fnRef2();
fnRef2();</pre></div><p>
<span class="emphasis"><em>Listing A.6</em></span>
</p><p>Each time this inner function is called, through a reference or otherwise, a new variable <code class="literal">innerVar</code> is created, incremented, and displayed:</p><div class="informalexample"><pre class="programlisting">innerVar = 1
innerVar = 1
innerVar = 1
innerVar = 1</pre></div><p>Inner functions can reference global variables in the same way as any other function can:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var globalVar = 0;</strong></span>
function outerFn() {
  function innerFn() {
<span class="strong"><strong>    globalVar++;</strong></span>
<span class="strong"><strong>    console.log('globalVar = ' + globalVar);</strong></span>
  }
  return innerFn;
}
var fnRef = outerFn();
fnRef();
fnRef();
var fnRef2 = outerFn();
fnRef2();
fnRef2();</pre></div><p>
<span class="emphasis"><em>Listing A.7</em></span>
</p><p>Now our function will <a id="id1110" class="indexterm"/>consistently <a id="id1111" class="indexterm"/>increment the variable with each call:</p><div class="informalexample"><pre class="programlisting">globalVar = 1
globalVar = 2
globalVar = 3
globalVar = 4</pre></div><p>But what if the variable is local to the parent function? Since the inner function inherits its parent's scope, this variable can be referenced too:</p><div class="informalexample"><pre class="programlisting">function outerFn() {
<span class="strong"><strong>  var outerVar = 0;</strong></span>
  function innerFn() {
<span class="strong"><strong>    outerVar++;</strong></span>
<span class="strong"><strong>    console.log('outerVar = ' + outerVar);</strong></span>
  }
  return innerFn;
}
var fnRef = outerFn();
fnRef();
fnRef();
var fnRef2 = outerFn();
fnRef2();
fnRef2();</pre></div><p>
<span class="emphasis"><em>Listing A.8</em></span>
</p><p>Now our function calls have more interesting behavior:</p><div class="informalexample"><pre class="programlisting">outerVar = 1
outerVar = 2
outerVar = 1
outerVar = 2</pre></div><p>This time we get a mix of the two earlier effects. The calls to <code class="literal">innerFn()</code> through each reference increment <code class="literal">outerVar</code> independently. Note that the second call to <code class="literal">outerFn()</code> is not resetting the value of <code class="literal">outerVar</code>, but rather creating a new instance of <code class="literal">outerVar</code> bound to the scope of the <a id="id1112" class="indexterm"/>second function call. The upshot of this is that after the previous calls, another call to <a id="id1113" class="indexterm"/>
<code class="literal">fnRef()</code> will print the value <code class="literal">3</code>, and a subsequent call to <code class="literal">fnRef2()</code> will also print <code class="literal">3</code>. The two counters are completely separate.</p><p>When a reference to an inner function <a id="id1114" class="indexterm"/>finds its way outside of the scope in which the function was defined, this creates a closure on that function. We call variables that are neither parameters nor local to the inner function's free variables, and the environment of the outer function call closes them. Essentially, the fact that the function refers to a local variable in the outer function grants the variable a stay of execution. The memory is not released when the function completes, as it is still needed by the closure.</p></div></div></div></body></html>
