<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter&#xA0;3.&#xA0;Handling Events</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="chapter" title="Chapter&#xA0;3.&#xA0;Handling Events"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter&#xA0;3.&#xA0;Handling Events</h1></div></div></div><p>JavaScript has several built-in ways of reacting to user interaction and other events. To make a page dynamic and responsive, we need to harness this capability so that we can, at the appropriate times, use the <a id="id162" class="indexterm"/>jQuery techniques we have learned so far and the other tricks we'll learn later. While we could do this with vanilla JavaScript, jQuery enhances and extends the basic event-handling mechanisms to give them a more elegant syntax while making them more powerful at the same time.</p><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Executing JavaScript code when the page is ready</li><li class="listitem" style="list-style-type: disc">Handling user events, such as mouse clicks and keystrokes</li><li class="listitem" style="list-style-type: disc">The flow of events through the document, and how to manipulate that flow</li><li class="listitem" style="list-style-type: disc">Simulating events as if the user initiated them</li></ul></div><div class="section" title="Performing tasks on page load"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Performing tasks on page load</h1></div></div></div><p>We have already seen how to <a id="id163" class="indexterm"/>
<a id="id164" class="indexterm"/>make jQuery react to the loading of a web page. The <code class="literal">$(document).ready()</code> event handler can be used to fire off a function's worth of code, but there's a bit more to be said about it.</p><div class="section" title="Timing of code execution"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Timing of code execution</h2></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter&#xA0;1.&#xA0;Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, we noted that <code class="literal">$(document).ready()</code> was jQuery's primary way to perform tasks on page load. It is not, however, the only method at our disposal. The native <code class="literal">window.onload</code> <a id="id165" class="indexterm"/>event can achieve a similar effect. While the two methods are similar, it is important to recognize their difference in timing, even though it can be quite subtle depending on the number of resources being loaded.</p><p>The <code class="literal">window.onload</code> event <a id="id166" class="indexterm"/>fires when a document is completely downloaded to the browser. This means that every element on the page is ready to be manipulated by JavaScript, which is a boon for writing feature-rich code without worrying about load order.</p><p>On the other hand, a handler registered using <code class="literal">$(document).ready()</code> is invoked when the DOM is completely ready for use. This also means that all elements are accessible by our scripts, but does not mean that every associated file has been downloaded. As soon as the HTML file has been downloaded and parsed into a DOM tree, the code can run.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>
<span class="strong"><strong>Style loading and code execution</strong></span>
</p><p>To ensure that the page has also been styled before the JavaScript code executes, it is good practice to place the <code class="literal">&lt;link rel="stylesheet"&gt;</code> and <code class="literal">&lt;style&gt;</code> tags prior to any <code class="literal">&lt;script&gt;</code> tags within the document's <code class="literal">&lt;head&gt;</code> element.</p></div></div><p>Consider, for example, a <a id="id167" class="indexterm"/>page that presents an image gallery; such a page may have many large images on it, which we can hide, show, move, and otherwise manipulate with jQuery. If we set up our interface using the <a id="id168" class="indexterm"/>
<code class="literal">onload</code> event, users will have to wait until each and every image is completely downloaded before they can use those features. Even worse, if behaviors are not yet attached to elements that have default behaviors (such as links), <a id="id169" class="indexterm"/>user interactions could produce unintended outcomes. However, when we use <code class="literal">$(document).ready()</code> for the setup, the interface is ready to be used earlier with the correct behavior.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>
<span class="strong"><strong>What is loaded and what is not?</strong></span>
</p><p>Using <code class="literal">$(document).ready()</code> is almost always preferred over using an <code class="literal">onload</code> handler, but we need to keep in mind that because supporting files may not have loaded, attributes such as image height and width are not necessarily available at this time. If these are needed, we may at times also choose to implement an <code class="literal">onload</code> <a id="id170" class="indexterm"/>handler (or more likely, use jQuery to bind a handler to the <code class="literal">load</code> event); the two mechanisms can coexist peacefully.</p></div></div></div><div class="section" title="Handling multiple scripts on one page"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Handling multiple scripts on one page</h2></div></div></div><p>The traditional <a id="id171" class="indexterm"/>mechanism for registering event handlers through JavaScript (rather than adding handler attributes right in the HTML content) is to assign a function to the DOM element's corresponding property. For example, suppose we had defined the following function:</p><div class="informalexample"><pre class="programlisting">function doStuff() {
  // Perform a task...
}</pre></div><p>We could then either assign it within our HTML markup:</p><div class="informalexample"><pre class="programlisting">&lt;body onload="doStuff();"&gt;</pre></div><p>Or, we could assign it from within JavaScript code:</p><div class="informalexample"><pre class="programlisting">window.onload = doStuff;</pre></div><p>Both of these approaches will cause the function to execute when the page is loaded. The advantage of the second is that the behavior is cleanly separated from the markup.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>
<span class="strong"><strong>Referencing versus calling functions</strong></span>
</p><p>When we assign a function as a handler, we use the function name but omit the trailing parentheses. With the parentheses, the function is called immediately; without the parantheses, the name simply identifies, or <span class="emphasis"><em>references</em></span>, the function, and can be used to call it later.</p></div></div><p>With one function, this <a id="id172" class="indexterm"/>strategy works quite well. However, suppose we have a second function as follows:</p><div class="informalexample"><pre class="programlisting">function doOtherStuff() {
  // Perform another task...
}</pre></div><p>We could then attempt to assign this function to run on page load:</p><div class="informalexample"><pre class="programlisting">window.onload = doOtherStuff;</pre></div><p>However, this assignment trumps the first one. The <code class="literal">.onload</code> attribute can only store one function reference at a time, so <a id="id173" class="indexterm"/>we can't add to the existing behavior.</p><p>The <code class="literal">$(document).ready()</code> mechanism handles this situation gracefully. Each call to the method adds the new function to an internal queue of behaviors; when the page is loaded, all of the functions will execute. The functions will run in the order in which they were registered.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>To be fair, jQuery doesn't have a monopoly on workarounds to this issue. We can write a JavaScript function that calls the existing <code class="literal">onload</code> handler <a id="id174" class="indexterm"/>then calls a passed-in handler. This approach avoids conflicts between rival handlers like <code class="literal">$(document).ready()</code> does, but lacks some of the other benefits we have discussed. In modern browsers, including Internet Explorer 9, the <a id="id175" class="indexterm"/>
<code class="literal">DOMContentLoaded</code> event can be triggered with the W3C standard <a id="id176" class="indexterm"/>
<code class="literal">document.addEventListener()</code> method. However, if we need to support older browsers as well, jQuery 1.<span class="emphasis"><em>x</em></span> versions handle the inconsistencies that these browsers present so that we don't have to handle them ourselves.</p></div></div></div><div class="section" title="Alternate syntax for .ready()"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Alternate syntax for .ready()</h2></div></div></div><p>The <code class="literal">$(document).ready()</code> construct is actually calling the <code class="literal">.ready()</code> method on a jQuery object we've constructed <a id="id177" class="indexterm"/>from the <code class="literal">document</code> DOM element. The <code class="literal">$()</code> function provides a shortcut for us as <a id="id178" class="indexterm"/>this is a common task. When we pass in a function as the argument to <code class="literal">$()</code>, jQuery performs an implicit call to <code class="literal">.ready()</code>. We normally write this construct in the following way:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  // Our code here...
});</pre></div><p>However, we can choose to use the following shorter version instead:</p><div class="informalexample"><pre class="programlisting">$(function() {
  // Our code here...
});</pre></div><p>While the latter syntax is shorter, the longer version makes code more descriptive about what it is doing. For this reason, we will use the longer syntax throughout this book.</p></div><div class="section" title="Passing an argument to the .ready() callback"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Passing an argument to the .ready() callback</h2></div></div></div><p>In some cases, it may prove useful to use more than one JavaScript library on the same page. Since many libraries <a id="id179" class="indexterm"/>make use of the <code class="literal">$</code> identifier (since it is short and convenient), we need a way to prevent collisions between these uses.</p><p>Fortunately, jQuery <a id="id180" class="indexterm"/>provides a method called <code class="literal">jQuery.noConflict()</code> to return control of the <code class="literal">$</code> identifier back to other libraries. Typical usage of <code class="literal">jQuery.noConflict()</code> follows the following pattern:</p><div class="informalexample"><pre class="programlisting">&lt;script src="prototype.js"&gt;&lt;/script&gt;
&lt;script src="jquery.js"&gt;&lt;/script&gt;
&lt;script&gt;
  jQuery.noConflict();
&lt;/script&gt;
&lt;script src="myscript.js"&gt;&lt;/script&gt;</pre></div><p>First, the other library (Prototype in this example) is included. Then, jQuery itself is included, taking over <code class="literal">$</code> for its own use. Next, a call to <code class="literal">.noConflict()</code> frees up <code class="literal">$</code>, so that control of it reverts to the first included library (Prototype). Now in our custom script we can use both libraries&#x2014;but whenever we want to use a jQuery method, we need to write <code class="literal">jQuery</code> instead of <code class="literal">$</code> as an identifier.</p><p>The <code class="literal">.ready()</code> method has one more trick up its sleeve to help us in this situation. The callback function we pass to it can <a id="id181" class="indexterm"/>take a single parameter&#x2014;the <code class="literal">jQuery</code> object itself. This allows us to effectively rename it without fear of conflicts using the following syntax:</p><div class="informalexample"><pre class="programlisting">jQuery(document).ready(function($) {
  // In here, we can use $ like normal!
});</pre></div><p>Or we can use the shorter <a id="id182" class="indexterm"/>syntax we learned previously:</p><div class="informalexample"><pre class="programlisting">jQuery(function($) {
  // Code that uses $.
});</pre></div></div></div></div></body></html>
