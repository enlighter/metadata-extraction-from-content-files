<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>DOM traversal under the hood</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="DOM traversal under the hood"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec73"/>DOM traversal under the hood</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter&#xA0;2.&#xA0;Selecting Elements">Chapter 2</a>, <span class="emphasis"><em>Selecting Elements</em></span>, and again at the beginning of this chapter, we looked at ways of traveling from one set of DOM <a id="id770" class="indexterm"/>elements to another by calling DOM traversal methods. Our (far from exhaustive) survey of such methods included simple ways to reach neighboring cells, such as <code class="literal">.next()</code> and <code class="literal">.parent()</code>, and more complex avenues of combining selector expressions, such as <code class="literal">.find()</code> and <code class="literal">.filter()</code>. By now, we should have a fairly strong grasp of these ways of getting from one DOM element to another step-by-step.</p><p>Each time we take one of these steps, though, jQuery takes note of our travels, laying down a trail of breadcrumbs we can follow back home if needed. A couple of the methods we briefly touched on in <a id="id771" class="indexterm"/>that chapter, <code class="literal">.end()</code> and <code class="literal">.addBack()</code>, take advantage of this record-keeping. To be able to get the most out of these methods, and in general to write efficient jQuery code, we need to understand a bit more about how the DOM traversal methods do their jobs.</p><div class="section" title="jQuery object properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec111"/>jQuery object properties</h2></div></div></div><p>As we know, we typically <a id="id772" class="indexterm"/>construct a jQuery object instance by passing a selector expression to the <code class="literal">$()</code> function. Within the resulting object, there lies an array structure containing references to each DOM element that matched that selector. What we haven't seen, though, are the other properties hidden in the object. Such properties include <code class="literal">.context</code>, a reference to the DOM node from which the search began (usually <code class="literal">document</code>), and <code class="literal">.selector</code>, a record of the selector expression that created the object. These two properties come into play when using <code class="literal">.on()</code> to perform event delegation, which we touched on in <a class="link" href="ch03.html" title="Chapter&#xA0;3.&#xA0;Handling Events">Chapter 3</a>, <span class="emphasis"><em>Handling Events</em></span>, and will investigate further in <a class="link" href="ch10.html" title="Chapter&#xA0;10.&#xA0;Advanced Events">Chapter 10</a>, <span class="emphasis"><em>Advanced Events</em></span>. When a DOM traversal method is called, though, a third property comes into play: <code class="literal">.prevObject</code> holds a reference to the jQuery object the traversal method was called upon.</p><p>To see this in action, we can highlight an arbitrary cell of our table and examine those properties:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  var $cell = $('#release');
  $cell.addClass('highlight');
  console.log($cell.context);
  console.log($cell.selector);
  console.log($cell.prevObject);
});</pre></div><p>
<span class="emphasis"><em>Listing 9.10</em></span>
</p><p>This snippet will highlight the single selected cell, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3145OS_09_10.jpg" alt="jQuery object properties"/></div><p>Three messages are also <a id="id773" class="indexterm"/>logged to the console:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Expression</p>
</th><th style="text-align: left" valign="bottom">
<p>Logged value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$cell.context</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Document</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$cell.selector</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">#release</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$cell.prevObject</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">undefined</code>
</p>
</td></tr></tbody></table></div><p>We can see that <code class="literal">.context</code> is the document object, <code class="literal">.selector</code> is the exact string that we passed to the object, and <code class="literal">.prevObject</code> is undefined since this is a newly-created object. If we add a traversal method to the mix, though, things get more interesting:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
<span class="strong"><strong>  var $cell = $('#release').nextAll();</strong></span>
  $cell.addClass('highlight');
  console.log($cell.context);
  console.log($cell.selector);
  console.log($cell.prevObject);
});</pre></div><p>
<span class="emphasis"><em>Listing 9.11</em></span>
</p><p>This change alters which cells are highlighted, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3145OS_09_11.jpg" alt="jQuery object properties"/></div><p>The log messages also change as a result of the <code class="literal">.nextAll()</code> call:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Expression</p>
</th><th style="text-align: left" valign="bottom">
<p>Logged value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$cell.context</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Document</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$cell.selector</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">#release.nextAll()</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$cell.prevObject</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">[td]</code>
</p>
</td></tr></tbody></table></div><p>Now the two cells following <a id="id774" class="indexterm"/>the one we initially selected are highlighted. Within the jQuery object, <code class="literal">.context</code> still points to the document object, but <code class="literal">.selector</code> has been modified to reflect our call to <code class="literal">.nextAll()</code>, and <code class="literal">.prevObject</code> refers to the original jQuery object instance before the call to <code class="literal">.nextAll()</code>.</p></div><div class="section" title="The DOM element stack"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec112"/>The DOM element stack</h2></div></div></div><p>Since each jQuery object <a id="id775" class="indexterm"/>instance has a <code class="literal">.prevObject</code> property <a id="id776" class="indexterm"/>pointing to the previous one, we have a linked list structure that implements a <span class="strong"><strong>stack</strong></span>. Each <a id="id777" class="indexterm"/>traversal method call finds a new set of elements and pushes this set onto the stack. This is only useful if we can do something with this stack, which is where the <code class="literal">.end()</code> and <code class="literal">.addBack()</code> methods come into play.</p><p>The <code class="literal">.end()</code> method <a id="id778" class="indexterm"/>simply pops one element off the end of the stack, which is the same as fetching the value of the <a id="id779" class="indexterm"/>
<code class="literal">.prevObject</code> property. We saw an example of this in <a class="link" href="ch02.html" title="Chapter&#xA0;2.&#xA0;Selecting Elements">Chapter 2</a>, <span class="emphasis"><em>Selecting Elements</em></span>, and we will see more later in this chapter. For a more interesting example, though, we'll investigate how <code class="literal">.addBack()</code> <a id="id780" class="indexterm"/>manipulates the stack:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#release').nextAll().addBack().addClass('highlight');
});</pre></div><p>
<span class="emphasis"><em>Listing 9.12</em></span>
</p><p>Once again, the highlighted cells have changed:</p><div class="mediaobject"><img src="graphics/3145OS_09_12.jpg" alt="The DOM element stack"/></div><p>When <code class="literal">.addBack()</code> is called, jQuery looks back one step on the stack and combines the two element sets. In our example, this means that the highlighted cells include both the two cells found by the <code class="literal">.nextAll()</code>
<a id="id781" class="indexterm"/> call and the original cell located using the selector. This new, merged element set is then pushed onto the stack.</p><p>This kind of stack manipulation <a id="id782" class="indexterm"/>can definitely be useful. To make sure these techniques work when they are needed, each traversal method implementation must properly update the stack; this means that we need to understand some of the system's inner workings if we want to provide traversal methods of our own.</p></div><div class="section" title="Writing a DOM traversal method plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec113"/>Writing a DOM traversal method plugin</h2></div></div></div><p>Like any other jQuery <a id="id783" class="indexterm"/>
<a id="id784" class="indexterm"/>object method, traversal methods can be added to jQuery by adding properties to <code class="literal">$.fn</code>. We saw in <a class="link" href="ch08.html" title="Chapter&#xA0;8.&#xA0;Developing Plugins">Chapter 8</a>, <span class="emphasis"><em>Developing Plugins</em></span>, that new jQuery methods we define should operate on the matched set of elements and then return the jQuery object so that users can chain on additional methods. When we create DOM traversal methods, the process is similar, but the jQuery object we return needs to point to a new set of matched elements.</p><p>As an example, we'll build a plugin that finds all of the table cells in the same column as a given cell. First we'll look at the plugin code in its entirety, then examine it piece-by-piece to understand how it works:</p><div class="informalexample"><pre class="programlisting">(function($) {
  $.fn.column = function() {
    var $cells = $();
    this.each(function() {
      var $td = $(this).closest('td, th');
      if ($td.length) {
        var colNum = $td[0].cellIndex + 1;
        var $columnCells = $td
          .closest('table')
          .find('td, th')
          .filter(':nth-child(' + colNum + ')');
        $cells = $cells.add($columnCells);
      }
    });
    return this.pushStack($cells);
  };
})(jQuery);</pre></div><p>
<span class="emphasis"><em>Listing 9.13</em></span>
</p><p>Our <code class="literal">.column()</code> method could be called on a jQuery object pointing to zero, one, or more DOM elements. To account for all of these possibilities, we use the <code class="literal">.each()</code> method to loop over the elements, adding the columns of cells one by one into the variable <code class="literal">$cells</code>. This <code class="literal">$cells</code> variable starts <a id="id785" class="indexterm"/>out as an empty jQuery object, but then is expanded with the <code class="literal">.add()</code> method to point to more and more DOM elements as needed.</p><p>This explains the outer loop of the function; inside the loop, we need to understand how <code class="literal">$columnCells</code> gets populated with the DOM elements in the table column. First, we get a reference to the table cell <a id="id786" class="indexterm"/>
<a id="id787" class="indexterm"/>being examined. We want to allow the <code class="literal">.column()</code> method to be called on table cells or on elements inside table cells. The <a id="id788" class="indexterm"/>
<code class="literal">.closest()</code> method takes care of this for us; it travels up the DOM tree until it finds an element matching the selector we provide. This method will prove very useful to us in event delegation, which we'll revisit in <a class="link" href="ch10.html" title="Chapter&#xA0;10.&#xA0;Advanced Events">Chapter 10</a>, <span class="emphasis"><em>Advanced Events</em></span>.</p><p>With our table cell in hand, we find its column number using the DOM <code class="literal">.cellIndex</code> property. This gives us a zero-based index of the cell's column; we add <code class="literal">1</code> to this number since we'll be using it in a one-based context later. Then, from the cell, we travel up to the nearest <code class="literal">&lt;table&gt;</code> element, back down to the <code class="literal">&lt;td&gt;</code> and <code class="literal">&lt;th&gt;</code> elements, and filter these cells down to the appropriate column with an <code class="literal">:nth-child()</code> selector expression.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/>Tip</h3><p>
<span class="strong"><strong>Handling nested tables</strong></span>
</p><p>The plugin we're writing is limited to simple, non-nested tables due to the <code class="literal">.find('td, th')</code> call. To support nested tables, we would need to determine whether <code class="literal">&lt;tbody&gt;</code> tags are present and move up and down the DOM tree by the appropriate amount, which would add more complexity than is appropriate for this example.</p></div></div><p>Once we've found all the cells in the column or columns, we need to return the new jQuery object. We could just return <code class="literal">$cells</code> from our method, but this wouldn't properly respect the DOM element stack. Instead, we pass <code class="literal">$cells</code> to the <code class="literal">.pushStack()</code> method and return the result. This method accepts an array of DOM elements and adds them to the stack, so that later calls to methods such as <code class="literal">.addBack()</code>and <code class="literal">.end()</code> behave correctly.</p><p>To see our plugin in action, we can react to clicks on cells and highlight the corresponding column:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $('#news td').click(function() {
    $('#news td.active').removeClass('active');
    $(this).column().addClass('active');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 9.14</em></span>
</p><p>The <code class="literal">active</code> class is added to the <a id="id789" class="indexterm"/>
<a id="id790" class="indexterm"/>selected column, resulting in different shading when, for instance, one of the author's names is clicked:</p><div class="mediaobject"><img src="graphics/3145OS_09_13.jpg" alt="Writing a DOM traversal method plugin"/></div></div><div class="section" title="DOM traversal performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec114"/>DOM traversal performance</h2></div></div></div><p>The rule of thumb about selector <a id="id791" class="indexterm"/>performance applies equally to DOM traversal performance: we should prioritize ease of code writing and code maintenance when possible, only sacrificing legibility for optimization when performance is a measurable problem. Again, sites such as <a class="ulink" href="http://jsperf.com/">http://jsperf.com/</a> are helpful in determining the best approach given several options.</p><p>While premature optimization should be avoided, it is good practice to minimize repetition of selectors and traversal methods. As these can be potentially expensive tasks, the fewer times we do them, the better. Two strategies for avoiding this repetition are <span class="strong"><strong>chaining</strong></span> and <span class="strong"><strong>object caching</strong></span>.</p><div class="section" title="Improving performance using chaining"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec24"/>Improving performance using chaining</h3></div></div></div><p>We have used chaining <a id="id792" class="indexterm"/>many times now, and it has <a id="id793" class="indexterm"/>allowed us to keep our code concise. There can be a performance benefit to chaining as well, however, if it allows us to reduce repetition.</p><p>Our <code class="literal">stripe()</code> function from <span class="emphasis"><em>Listing 9.9</em></span> located the element with ID <code class="literal">news</code> twice: once to remove the <code class="literal">alt</code> class from rows that no longer needed it, and once to apply that class to the new set of rows. Using chaining, we can combine these two thoughts into one and prevent this repetition:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  function stripe() {
    $('#news')
      .find('tr.alt').removeClass('alt').end()
      .find('tbody').each(function() {
        $(this).children(':visible').has('td')
          .filter(':group(3)').addClass('alt');
      });
  }
  stripe();
});</pre></div><p>
<span class="emphasis"><em>Listing 9.15</em></span>
</p><p>In order to merge the two uses of <code class="literal">$('#news')</code>, we once again exploit the DOM element stack within the jQuery object. The first call to <code class="literal">.find()</code> pushes the table rows onto the stack, but then <code class="literal">.end()</code> pops this off the stack so that the next <code class="literal">.find()</code> call is operating on the <code class="literal">news</code> table once again. This <a id="id794" class="indexterm"/>kind of clever <a id="id795" class="indexterm"/>manipulation of the stack is a handy way of avoiding selector duplication.</p></div><div class="section" title="Improving performance with caching"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec25"/>Improving performance with caching</h3></div></div></div><p>Caching is simply storing <a id="id796" class="indexterm"/>the result of an operation so that <a id="id797" class="indexterm"/>it can be used multiple times without running the operation again. In the context of selector and traversal performance, we can use caching by storing a jQuery object in a variable for later use rather than creating a new one.</p><p>Returning to our example, we can rewrite the <code class="literal">stripe()</code> function to avoid selector duplication with caching rather than chaining:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
<span class="strong"><strong>  var $news = $('#news');</strong></span>
  function stripe() {
<span class="strong"><strong>    $news.find('tr.alt').removeClass('alt');</strong></span>
<span class="strong"><strong>    $news.find('tbody').each(function() {</strong></span>
      $(this).children(':visible').has('td')
        .filter(':group(3)').addClass('alt');
    });
  }
  stripe();
});</pre></div><p>
<span class="emphasis"><em>Listing 9.16</em></span>
</p><p>The two operations are separate JavaScript statements once again, rather than being chained together. We're still executing the <code class="literal">$('#news')</code> selector only once, though, by storing the result in <code class="literal">$news</code>. This caching approach is a little more verbose than chaining, since we need to separately create the variable storing the jQuery object. On the other hand, it has the advantage of allowing the two uses of the selected elements to be far apart in the code if we need them to be. Also, since we can cache the selected elements outside the <code class="literal">stripe()</code> function, the selector doesn't need to be re-run each time the function is called.</p><p>Because selecting elements on the page by ID is extremely fast, neither of these examples will have a big performance impact, and in practice, we'd choose the approach that seemed the most legible <a id="id798" class="indexterm"/>and maintainable. <a id="id799" class="indexterm"/>These techniques are useful tools, though, when performance is found to be a concern.</p></div></div></div></body></html>
