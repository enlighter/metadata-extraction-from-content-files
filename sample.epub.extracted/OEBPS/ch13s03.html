<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Using the jqXHR object</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Using the jqXHR object"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec102"/>Using the jqXHR object</h1></div></div></div><p>When an Ajax request is made, <a id="id1052" class="indexterm"/>jQuery determines the best mechanism available for retrieving the data. This transport could be the standard <code class="literal">XMLHttpRequest</code> object, <a id="id1053" class="indexterm"/>the Microsoft ActiveX <code class="literal">XMLHTTP</code> object or a <code class="literal">&lt;script&gt;</code> tag.</p><p>Because the transport used can vary from request to request, we need a common interface in order to interact with the communication. The <code class="literal">jqXHR</code> object provides this interface for us: it is a wrapper for the <code class="literal">XMLHttpRequest</code> object when that transport is used, and in other cases, it simulates <code class="literal">XMLHttpRequest</code> as best it can. Among the properties and methods it exposes are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">.responseText</code> or <code class="literal">.responseXML</code> <a id="id1054" class="indexterm"/>containing the <a id="id1055" class="indexterm"/>returned data</li><li class="listitem" style="list-style-type: disc"><code class="literal">.status</code> and <code class="literal">.statusText</code> <a id="id1056" class="indexterm"/>containing <a id="id1057" class="indexterm"/>a status code and description</li><li class="listitem" style="list-style-type: disc"><code class="literal">.setRequestHeader()</code> to <a id="id1058" class="indexterm"/>manipulate the HTTP headers sent with the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">.abort()</code> to prematurely halt the transaction</li></ul></div><p>This <code class="literal">jqXHR</code> object is returned from all the jQuery's Ajax methods, so we can store the result if we need access to any of these properties or methods.</p><div class="section" title="Ajax promises"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec146"/>Ajax promises</h2></div></div></div><p>Perhaps a more important aspect <a id="id1059" class="indexterm"/>of <code class="literal">jqXHR</code> than the <code class="literal">XMLHttpRequest</code> interface, however, is that it also acts as a promise. In <a class="link" href="ch11.html" title="Chapter&#xA0;11.&#xA0;Advanced Effects">Chapter 11</a>, <span class="emphasis"><em>Advanced Effects</em></span>, we learned about deferred objects, which allow us to set callbacks to be fired when certain operations complete. An Ajax call is an example of such operation, and the <code class="literal">jqXHR</code> object provides the methods we expect from a deferred object's promise.</p><p>Using the promise's methods, we can rewrite our <code class="literal">$.ajax()</code> call to replace the success and error callbacks with an alternate syntax:</p><div class="informalexample"><pre class="programlisting">$.ajax({
  url: 'http://book.learningjquery.com/api/',
  dataType: 'jsonp',
  data: {
    title: $('#title').val()
  },
  timeout: 15000
})
<span class="strong"><strong>.done(response)</strong></span>
<span class="strong"><strong>.fail(function() {</strong></span>
<span class="strong"><strong>  $response.html(failed);</strong></span>
<span class="strong"><strong>});</strong></span>
</pre></div><p>
<span class="emphasis"><em>Listing 13.7</em></span>
</p><p>At first glance, calling <code class="literal">.done()</code> and <code class="literal">.fail()</code> doesn't seem any more useful than the callback syntax we used previously. However, the promise methods offer several advantages. First, the methods can be called multiple times to add more than one handler if desired. Second, if we store the result of the <a id="id1060" class="indexterm"/>
<code class="literal">$.ajax()</code> call in a variable, we can attach the handlers later if that makes our code structure more readable. Third, the handlers will be invoked immediately if the Ajax operation is already complete when they are attached. Finally, we should not discount the <a id="id1061" class="indexterm"/>readability advantage of using a syntax that is consistent with other parts of the jQuery library.</p><p>As another example of using the promise methods, we can add a loading indicator when a request is made. Since we want to hide the indicator when the request completes successfully or otherwise, the <code class="literal">.always()</code> method will come in handy:</p><div class="informalexample"><pre class="programlisting">$ajaxForm.on('submit', function(event) {
  event.preventDefault();

<span class="strong"><strong>  $response.addClass('loading').empty();</strong></span>

  $.ajax({
    url: 'http://book.learningjquery.com/api/',
    dataType: 'jsonp',
    data: {
      title: $('#title').val()
    },
    timeout: 15000
  })
  .done(response)
  .fail(function() {
    $response.html(failed);
  })
<span class="strong"><strong>  .always(function() {</strong></span>
<span class="strong"><strong>    $response.removeClass('loading');</strong></span>
<span class="strong"><strong>  });</strong></span>
});</pre></div><p>
<span class="emphasis"><em>Listing 13.8</em></span>
</p><p>Before we issue the <code class="literal">$.ajax()</code> call, we add the <code class="literal">loading</code> class to the response container. Once the load is complete, we remove it again. In this way, we have further enhanced the user experience.</p><p>To really get a grasp of how the <a id="id1062" class="indexterm"/>promise behavior can help us, though, we need to look at what we can do if we store the result of our <code class="literal">$.ajax()</code> call in a variable for later use.</p></div><div class="section" title="Caching responses"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec147"/>Caching responses</h2></div></div></div><p>If we need to use the same piece of data repeatedly, it is wasteful to make an Ajax request each time. To prevent this, we can cache the returned data in a variable. When we need to use some data, we can check to see if the data is <a id="id1063" class="indexterm"/>already in the cache. If so, we act on this data. If not, we need to make an Ajax request, and in its <code class="literal">.done()</code> handler, we store the data in the cache and act on the returned data.</p><p>This is a lot of steps. If we exploit the properties of promises, it can be quite simple:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var api = {};</strong></span>

$ajaxForm.on('submit', function(event) {
  event.preventDefault();

  $response.empty();

  var search = $('#title').val();
  if (search == '') {
    return;
  }

  $response.addClass('loading');

<span class="strong"><strong>  if (!api[search]) {</strong></span>
<span class="strong"><strong>    api[search] = $.ajax({</strong></span>
      url: 'http://book.learningjquery.com/api/',
      dataType: 'jsonp',
      data: {
        title: search
      },
      timeout: 15000
    });
  }
<span class="strong"><strong>  api[search].done(response).fail(function() {</strong></span>
    $response.html(failed);
  }).always(function() {
    $response.removeClass('loading');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 13.9</em></span>
</p><p>We've introduced a new variable named <code class="literal">api</code> to hold the <code class="literal">jqXHR</code> objects we create. This variable is an object with keys corresponding to the searches being performed. When the form is submitted, we look to see if there is already a <code class="literal">jqXHR</code> object stored for that key. If not, we do the query as before, storing the resulting object inside <code class="literal">api</code>.</p><p>The <code class="literal">.done()</code>, <code class="literal">.fail()</code>, and <code class="literal">.always()</code> handlers are then attached to the <code class="literal">jqXHR</code> object. Note that this <a id="id1064" class="indexterm"/>happens <a id="id1065" class="indexterm"/>regardless of whether an Ajax request was made. There are two <a id="id1066" class="indexterm"/>possible situations to consider here.</p><p>First, the Ajax request might be sent if it hasn't before. This is just like the previous behavior: the request is issued and we use the promise methods to attach handlers to the <code class="literal">jqXHR</code> object. When a response comes back from the server, the appropriate callbacks are fired and the result is printed to the screen.</p><p>On the other hand, if we have performed this search in the past, the <code class="literal">jqXHR</code> object is already stored in <code class="literal">api</code>. In this case, no new search is performed, but we still call the promise methods on the stored object. This attaches new handlers to the object, but since the deferred object has already been resolved, the relevant handlers are fired immediately.</p><p>The jQuery deferred object system handles all the hard work for us. With a couple of lines of code, we have eliminated duplicated network requests from the application.</p></div></div></body></html>
