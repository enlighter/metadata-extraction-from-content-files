<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Extending Ajax capabilities</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Extending Ajax capabilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec104"/>Extending Ajax capabilities</h1></div></div></div><p>The jQuery Ajax framework is powerful, as we've seen, but even so there are times when we might want to change the way it behaves. Unsurprisingly, it offers multiple hooks that can be used by plugins to give the framework brand new capabilities.</p><div class="section" title="Data type converters"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec148"/>Data type converters</h2></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter&#xA0;6.&#xA0;Sending Data with Ajax">Chapter 6</a>, <span class="emphasis"><em>Sending Data with Ajax</em></span>, <a id="id1068" class="indexterm"/>we saw that the <code class="literal">$.ajaxSetup()</code> function allows us to change the defaults used by <code class="literal">$.ajax()</code>, thus potentially affecting many Ajax operations with a single statement. This same function can also be used to add to the range of data types that <code class="literal">$.ajax()</code> can request and interpret.</p><p>As an example, we can add a converter that understands the YAML data format. YAML (<a class="ulink" href="http://www.yaml.org/">http://www.yaml.org/</a>) is a <a id="id1069" class="indexterm"/>popular data representation with implementations in many programming languages. In our case, script needs to interact with an alternative format such as this; jQuery allows us to build compatibility for them it into the native Ajax functions.</p><p>A simple <a id="id1070" class="indexterm"/>YAML file containing <a id="id1071" class="indexterm"/>jQuery method categories and subcategories looks like this:</p><div class="informalexample"><pre class="programlisting">Ajax:
- Global Ajax Event Handlers
- Helper Functions
- Low-Level Interface
- Shorthand Methods
Effects:
- Basics
- Custom
- Fading
- Sliding</pre></div><p>We can wrap jQuery around an existing YAML parser such as Diogo Costa's (<a class="ulink" href="http://code.google.com/p/javascript-yaml-parser/">http://code.google.com/p/javascript-yaml-parser/</a>) to make <code class="literal">$.ajax()</code> speak this language as well.</p><p>Defining a new Ajax data type involves passing three properties to <code class="literal">$.ajaxSetup()</code>: <code class="literal">accepts</code>, <code class="literal">contents</code>, and <code class="literal">converters</code>. The <a id="id1072" class="indexterm"/>
<code class="literal">accepts</code> property adds headers to be sent to the server, declaring to the server that particular MIME types are understood by our script. The <a id="id1073" class="indexterm"/>
<code class="literal">contents</code> property handles the other side of the transaction, providing a regular expression that is matched against the response MIME type to attempt to autodetect the data type from this metadata. Finally, <code class="literal">converters</code> contains the actual functions that parse the returned data:</p><div class="informalexample"><pre class="programlisting">$.ajaxSetup({
  accepts: {
    yaml: 'application/x-yaml, text/yaml'
  },
  contents: {
    yaml: /yaml/
  },
  converters: {
    'text yaml': function(textValue) {
      console.log(textValue);
      return '';
    }
  }
});

$.ajax({
  url: 'categories.yml',
  dataType: 'yaml'
});</pre></div><p>
<span class="emphasis"><em>Listing 13.12</em></span>
</p><p>The partial implementation in <span class="emphasis"><em>Listing 13.12</em></span> uses <code class="literal">$.ajax()</code> to read in the YAML file, and declares its data type as <code class="literal">yaml</code>. Because the incoming data is parsed as <code class="literal">text</code>, jQuery needs a way to convert one data type to the other. The <code class="literal">converters</code> key of <code class="literal">'text yaml'</code> tells jQuery that this conversion function will accept data that has been received as <code class="literal">text</code> and reinterpret it as <code class="literal">yaml</code>.</p><p>Inside the conversion function, we are simply logging out the contents of the text to ensure that the function is called <a id="id1074" class="indexterm"/>correctly. To actually perform the conversion, we need to load the third-party YAML parsing library (<code class="literal">yaml.js</code>) and call its methods:</p><div class="informalexample"><pre class="programlisting">$.ajaxSetup({
  accepts: {
    yaml: 'application/x-yaml, text/yaml'
  },
  contents: {
    yaml: /yaml/
  },
  converters: {
    'text yaml': function(textValue) {
<span class="strong"><strong>      var result = YAML.eval(textValue);</strong></span>
<span class="strong"><strong>      var errors = YAML.getErrors();</strong></span>
<span class="strong"><strong>      if (errors.length) {</strong></span>
<span class="strong"><strong>        throw errors;</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>      return result;</strong></span>
    }
  }
});

<span class="strong"><strong>$.getScript('yaml.js').done(function() {</strong></span>
  $.ajax({
    url: 'categories.yml',
    dataType: 'yaml'
<span class="strong"><strong>  }).done(function (data) {</strong></span>
<span class="strong"><strong>    var cats = '';</strong></span>
<span class="strong"><strong>    $.each(data, function(category, subcategories) {</strong></span>
<span class="strong"><strong>      cats += '&lt;li&gt;&lt;a href="#"&gt;' + category + '&lt;/a&gt;&lt;/li&gt;';</strong></span>
<span class="strong"><strong>    });</strong></span>

<span class="strong"><strong>    $(document).ready(function() {</strong></span>
<span class="strong"><strong>      var $cats = $('#categories').removeClass('hide');</strong></span>
<span class="strong"><strong>      $('&lt;ul&gt;&lt;/ul&gt;', {</strong></span>
<span class="strong"><strong>        html: cats</strong></span>
<span class="strong"><strong>      }).appendTo($cats);</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>  });</strong></span>
});</pre></div><p>
<span class="emphasis"><em>Listing 13.13</em></span>
</p><p>The <code class="literal">yaml.js</code> file includes <a id="id1075" class="indexterm"/>an object named <code class="literal">YAML</code> with <code class="literal">.eval()</code> and <code class="literal">.getErrors()</code> methods. We use these methods to parse the incoming text and return the result, which is a JavaScript object containing all of the <code class="literal">categories.yml</code> file's data in an easily traversable structure. Since the file <a id="id1076" class="indexterm"/>we're loading contains categories of jQuery methods, we use the parsed structure to print out the top-level categories and later will allow the user to filter their search results by clicking on the categories:</p><div class="mediaobject"><img src="graphics/3145OS_13_04.jpg" alt="Data type converters"/></div><p>Note that when we insert the category names, we need to wrap that portion of the code in a <code class="literal">$(document).ready()</code> call. <a id="id1077" class="indexterm"/>The Ajax operations may run immediately, without access to the DOM, but once we have a result from them, we need to wait until the DOM is available before proceeding. Structuring our code in this way allows the work to be performed as early as possible, <a id="id1078" class="indexterm"/>improving the user's perception of the page's loading time.</p><p>Next, we need to handle clicks on the category links:</p><div class="informalexample"><pre class="programlisting">$(document).on('click', '#categories a', function(event) {
  event.preventDefault();
  $(this).parent().toggleClass('active')
    .siblings('.active').removeClass('active');
  $('#ajax-form').triggerHandler('submit');
});</pre></div><p>
<span class="emphasis"><em>Listing 13.14</em></span>
</p><p>By binding our <code class="literal">click</code> handler to document and relying on event delegation, we avoid some costly repetition and we also can run the code right away, without concerning ourselves with waiting for the Ajax call to complete.</p><p>Inside the handler, we make sure the right category is highlighted and then trigger the <code class="literal">submit</code> handler on the form. We <a id="id1079" class="indexterm"/>haven't yet made the form understand our category list, but the highlighting works already:</p><div class="mediaobject"><img src="graphics/3145OS_13_05.jpg" alt="Data type converters"/></div><p>Finally, we need to update the form's <code class="literal">submit</code> handler to respect the active category if there is one:</p><div class="informalexample"><pre class="programlisting">$ajaxForm.on('submit', function(event) {
  event.preventDefault();

  $response.empty();

  var title = $('#title').val(),
<span class="strong"><strong>      category = $('#categories').find('li.active').text(),</strong></span>
<span class="strong"><strong>      search = category + '-' + title;</strong></span>
  if (search == '-') {
    return;
  }

  $response.addClass('loading');

  if (!api[search]) {
    api[search] = $.ajax({
      url: 'http://book.learningjquery.com/api/',
      dataType: 'jsonp',
      data: {
        title: title,
<span class="strong"><strong>        category: category</strong></span>
      },
      timeout: 15000
    });
  }
  api[search].done(response).fail(function() {
    $response.html(failed);
  }).always(function() {
    $response.removeClass('loading');
  });
});

$('#title').on('keyup', function(event) {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(function() {
    $ajaxForm.triggerHandler('submit');
  }, searchDelay);
});</pre></div><p>
<span class="emphasis"><em>Listing 13.15</em></span>
</p><p>Instead of simply fetching the value of the search field, now we retrieve the text of the active category as well, passing both pieces of information on through the Ajax call. We also change the <code class="literal">search</code> variable to <a id="id1080" class="indexterm"/>contain both the category and the title. This way, our cache of search results correctly distinguishes searches on the same text in different categories.</p><p>We can now view all methods in a category by clicking on that category's name or use the category list to filter the results we obtain by typing in the search field.</p><div class="mediaobject"><img src="graphics/3145OS_13_06.jpg" alt="Data type converters"/></div><p>Anytime we have the need to support new data types not already handled by jQuery, we can define them in a similar fashion <a id="id1081" class="indexterm"/>to this YAML example. We can thus shape jQuery's Ajax library to our specific project's needs.</p></div><div class="section" title="Adding Ajax prefilters"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec149"/>Adding Ajax prefilters</h2></div></div></div><p>The <code class="literal">$.ajaxPrefilter()</code> function can add prefilters, which are callback functions that allow us to manipulate requests <a id="id1082" class="indexterm"/>before they are sent. Prefilters are invoked before <code class="literal">$.ajax()</code> changes or uses any of its options, so they are a good place to change the options or act on new custom options.</p><p>Prefilters can also manipulate the <a id="id1083" class="indexterm"/>data type of the request by simply returning the name of <a id="id1084" class="indexterm"/>the new data type to use. In our YAML example, we specified <code class="literal">yaml</code> as the data type because we didn't want to rely on the server supplying the correct MIME type for the response. We could, though, provide a prefilter that ensures the data type is <code class="literal">yaml</code> if the corresponding file extension <code class="literal">(.yml</code>) is in the URL we request:</p><div class="informalexample"><pre class="programlisting">$.ajaxPrefilter(function(options) {
  if (/\.yml$/.test(options.url)) {
    return 'yaml';
  }
});</pre></div><p>
<span class="emphasis"><em>Listing 13.16</em></span>
</p><p>A short regular expression tests whether <code class="literal">.yml</code> is at the end of <code class="literal">options.url</code> and, if so, defines the data type as <code class="literal">yaml</code>. With this prefilter in place, our Ajax call to fetch the YAML document no longer needs to explicitly define its data type.</p></div><div class="section" title="Defining alternate transports"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec150"/>Defining alternate transports</h2></div></div></div><p>We've seen that jQuery uses <code class="literal">XMLHttpRequest</code>, <code class="literal">ActiveX</code>, or <code class="literal">&lt;script&gt;</code> tags as appropriate to handle Ajax <a id="id1085" class="indexterm"/>transactions. If we wish, we can further extend this arsenal with new transports.</p><p>A transport is an object that handles the actual transmission of Ajax data. New transports are defined as factory functions <a id="id1086" class="indexterm"/>that return an object with the <code class="literal">.send()</code> and <code class="literal">.abort()</code> methods. The <code class="literal">.send()</code> method <a id="id1087" class="indexterm"/>is responsible for issuing the request, handling the response and sending the data back through a callback function. The <code class="literal">.abort()</code> method <a id="id1088" class="indexterm"/>should stop the request immediately.</p><p>A custom transport can, for example, use <code class="literal">&lt;img&gt;</code> elements to fetch external data. This allows image loading to be handled in the same way as other Ajax requests, which can help make our code more internally consistent. The JavaScript required to create such a transport is a little involved, so we will look at the finished product and then discuss its components:</p><div class="informalexample"><pre class="programlisting">$.ajaxTransport('img', function(settings) {
  var $img, img, prop;
  return {
    send: function(headers, complete) {
      function callback(success) {
        if (success) {
          complete(200, 'OK', {img: img});
        } else {
          $img.remove();
          complete(404, 'Not Found');
        }
      }

      $img = $('&lt;img&gt;', {
        src: settings.url
      });
      img = $img[0];
      prop = typeof img.naturalWidth === 'undefined' ? 'width' : 'naturalWidth';
      if (img.complete) {
        callback( !!img[prop] );
      } else {
        $img.on('load error', function(event) {
          callback(event.type == 'load');
        });
      }

    },
    abort: function() {
      if ($img) {
        $img.remove();
      }
    }
  };
});</pre></div><p>
<span class="emphasis"><em>Listing 13.17</em></span>
</p><p>When defining a transport, we first pass a data type name into <code class="literal">$.ajaxTransport()</code>. This tells jQuery when to use our transport rather than the built-in mechanisms. Then, we provide a function that returns the new transport object containing the appropriate <code class="literal">.send()</code> and <code class="literal">.abort()</code> methods.</p><p>For our <code class="literal">img</code> transport, the <code class="literal">.send()</code> method <a id="id1089" class="indexterm"/>needs to create a new <code class="literal">&lt;img&gt;</code> element, which we give a <code class="literal">src</code> attribute. The value of this attribute comes from <code class="literal">settings.url</code>, which jQuery passes along from the <code class="literal">$.ajax()</code> call. The browser will react to the creation of this <code class="literal">&lt;img&gt;</code> element by loading <a id="id1090" class="indexterm"/>the referenced image file, so we just need to detect when this load has completed and fire the completion callback.</p><p>Correctly detecting the completion of an image load is tricky if we want to handle a wide variety of browsers and versions. In some browsers, we can simply attach <code class="literal">load</code> and error <code class="literal">event</code> handlers to the image element. In others, though, when the image is cached, <code class="literal">load</code> and <code class="literal">error</code> are not triggered as expected.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>See Lucas Smith's blog article, <span class="emphasis"><em>Is My Image Loaded?</em></span> at <a class="ulink" href="http://www.verious.com/tool/is-my-image-loaded/">http://www.verious.com/tool/is-my-image-loaded/</a> for more details about browser inconsistencies regarding image loading.</p></div></div><p>Our code in <span class="emphasis"><em>Listing 13.17</em></span> handles these unusual browser behaviors by examining the values <a id="id1091" class="indexterm"/>of the <code class="literal">.complete</code>, <code class="literal">.width</code>, <a id="id1092" class="indexterm"/>and <code class="literal">.naturalWidth</code> <a id="id1093" class="indexterm"/>properties as appropriate for each browser. Once we have detected that the image load has either successfully completed or failed, we call the <a id="id1094" class="indexterm"/>
<code class="literal">callback()</code> function, which in turn calls the <code class="literal">complete()</code> function that was passed to <code class="literal">.send()</code>. This allows <code class="literal">$.ajax()</code> to react to the image load.</p><p>Handling aborted loads is much simpler. <a id="id1095" class="indexterm"/>Our <code class="literal">.abort()</code> method simply needs to clean up after <code class="literal">.send()</code> by removing the <code class="literal">&lt;img&gt;</code> element if it has been created.</p><p>Next, we need to write the <code class="literal">$.ajax()</code> call that uses our new transport:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $.ajax({
    url: 'missing.jpg',
    dataType: 'img'
  }).done(function(img) {
    $('&lt;div&gt;&lt;/div&gt;', {
      id: 'picture',
      html: img
    }).appendTo('body');
  }).fail(function(xhr, textStatus, msg) {
    $('&lt;div&gt;&lt;/div&gt;', {
      id: 'picture',
      html: textStatus + ': ' + msg
    }).appendTo('body');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 13.18</em></span>
</p><p>To use a particular transport, <code class="literal">$.ajax()</code> needs to be given a corresponding <code class="literal">dataType</code> value. Then, the success and <a id="id1096" class="indexterm"/>failure handlers need to take into account the kind of data that is passed to them. Our <a id="id1097" class="indexterm"/>
<code class="literal">img</code> transport returns an <code class="literal">&lt;img&gt;</code> DOM element when it is successful, so our <code class="literal">.done()</code> handler uses this element as the HTML contents of a newly created <code class="literal">&lt;div&gt;</code> element that is inserted into the document.</p><p>However, in this case, the <a id="id1098" class="indexterm"/>specified image file (<code class="literal">missing.jpg</code>) does not actually exist. We take into account such a possibility with an appropriate <code class="literal">.fail()</code> handler, which inserts an error message into the <code class="literal">&lt;div&gt;</code> where the image would otherwise go:</p><div class="mediaobject"><img src="graphics/3145OS_13_07.jpg" alt="Defining alternate transports"/></div><p>We can correct this error by referencing an image that does exist:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
  $.ajax({
<span class="strong"><strong>    url: 'sunset.jpg',</strong></span>
    dataType: 'img'
  }).done(function(img) {
    $('&lt;div&gt;&lt;/div&gt;', {
      id: 'picture',
      html: img
    }).appendTo('body');
  }).fail(function(xhr, textStatus, msg) {
    $('&lt;div&gt;&lt;/div&gt;', {
      id: 'picture',
      html: textStatus + ': ' + msg
    }).appendTo('body');
  });
});</pre></div><p>
<span class="emphasis"><em>Listing 13.19</em></span>
</p><p>Now our transport is able to successfully load the image and we see this result on the page:</p><div class="mediaobject"><img src="graphics/3145OS_13_08.jpg" alt="Defining alternate transports"/></div><p>Creating a new transport is an unusual need, but even in this case, jQuery's Ajax functionality can be bent to our needs.</p></div></div></body></html>
